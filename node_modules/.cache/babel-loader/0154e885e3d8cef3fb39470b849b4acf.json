{"ast":null,"code":"import { isNullOrUndefined, getValue, extend, isBlazor } from './util';\n\nvar Observer =\n/** @class */\nfunction () {\n  function Observer(context) {\n    this.ranArray = [];\n    this.boundedEvents = {};\n\n    if (isNullOrUndefined(context)) {\n      return;\n    }\n\n    this.context = context;\n  }\n  /**\n   * To attach handler for given property in current context.\n   *\n   * @param {string} property - specifies the name of the event.\n   * @param {Function} handler - Specifies the handler function to be called while event notified.\n   * @param {Object} context - Specifies the context binded to the handler.\n   * @param {string} id - specifies the random generated id.\n   * @returns {void}\n   */\n\n\n  Observer.prototype.on = function (property, handler, context, id) {\n    if (isNullOrUndefined(handler)) {\n      return;\n    }\n\n    var cntxt = context || this.context;\n\n    if (this.notExist(property)) {\n      this.boundedEvents[property] = [{\n        handler: handler,\n        context: cntxt\n      }];\n      return;\n    }\n\n    if (!isNullOrUndefined(id)) {\n      if (this.ranArray.indexOf(id) === -1) {\n        this.ranArray.push(id);\n        this.boundedEvents[property].push({\n          handler: handler,\n          context: cntxt,\n          id: id\n        });\n      }\n    } else if (!this.isHandlerPresent(this.boundedEvents[property], handler)) {\n      this.boundedEvents[property].push({\n        handler: handler,\n        context: cntxt\n      });\n    }\n  };\n  /**\n   * To remove handlers from a event attached using on() function.\n   *\n   * @param {string} property - specifies the name of the event.\n   * @param {Function} handler - Optional argument specifies the handler function to be called while event notified.\n   * @param {string} id - specifies the random generated id.\n   * @returns {void} ?\n   */\n\n\n  Observer.prototype.off = function (property, handler, id) {\n    if (this.notExist(property)) {\n      return;\n    }\n\n    var curObject = getValue(property, this.boundedEvents);\n\n    if (handler) {\n      for (var i = 0; i < curObject.length; i++) {\n        if (id) {\n          if (curObject[i].id === id) {\n            curObject.splice(i, 1);\n            var indexLocation = this.ranArray.indexOf(id);\n\n            if (indexLocation !== -1) {\n              this.ranArray.splice(indexLocation, 1);\n            }\n\n            break;\n          }\n        } else if (handler === curObject[i].handler) {\n          curObject.splice(i, 1);\n          break;\n        }\n      }\n    } else {\n      delete this.boundedEvents[property];\n    }\n  };\n  /**\n   * To notify the handlers in the specified event.\n   *\n   * @param {string} property - Specifies the event to be notify.\n   * @param {Object} argument - Additional parameters to pass while calling the handler.\n   * @param {Function} successHandler - this function will invoke after event successfully triggered\n   * @param {Function} errorHandler - this function will invoke after event if it was failure to call.\n   * @returns {void} ?\n   */\n\n\n  Observer.prototype.notify = function (property, argument, successHandler, errorHandler) {\n    if (this.notExist(property)) {\n      if (successHandler) {\n        successHandler.call(this, argument);\n      }\n\n      return;\n    }\n\n    if (argument) {\n      argument.name = property;\n    }\n\n    var blazor = 'Blazor';\n    var curObject = getValue(property, this.boundedEvents).slice(0);\n\n    if (window[blazor]) {\n      return this.blazorCallback(curObject, argument, successHandler, errorHandler, 0);\n    } else {\n      for (var _i = 0, curObject_1 = curObject; _i < curObject_1.length; _i++) {\n        var cur = curObject_1[_i];\n        cur.handler.call(cur.context, argument);\n      }\n\n      if (successHandler) {\n        successHandler.call(this, argument);\n      }\n    }\n  };\n\n  Observer.prototype.blazorCallback = function (objs, argument, successHandler, errorHandler, index) {\n    var _this = this;\n\n    var isTrigger = index === objs.length - 1;\n\n    if (index < objs.length) {\n      var obj_1 = objs[index];\n      var promise = obj_1.handler.call(obj_1.context, argument);\n\n      if (promise && typeof promise.then === 'function') {\n        if (!successHandler) {\n          return promise;\n        }\n\n        promise.then(function (data) {\n          data = typeof data === 'string' && _this.isJson(data) ? JSON.parse(data, _this.dateReviver) : data;\n          extend(argument, argument, data, true);\n\n          if (successHandler && isTrigger) {\n            successHandler.call(obj_1.context, argument);\n          } else {\n            return _this.blazorCallback(objs, argument, successHandler, errorHandler, index + 1);\n          }\n        }).catch(function (data) {\n          if (errorHandler) {\n            errorHandler.call(obj_1.context, typeof data === 'string' && _this.isJson(data) ? JSON.parse(data, _this.dateReviver) : data);\n          }\n        });\n      } else if (successHandler && isTrigger) {\n        successHandler.call(obj_1.context, argument);\n      } else {\n        return this.blazorCallback(objs, argument, successHandler, errorHandler, index + 1);\n      }\n    }\n  }; // eslint-disable-next-line\n\n\n  Observer.prototype.dateReviver = function (key, value) {\n    var dPattern = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}/;\n\n    if (isBlazor && typeof value === 'string' && value.match(dPattern) !== null) {\n      return new Date(value);\n    }\n\n    return value;\n  };\n\n  Observer.prototype.isJson = function (value) {\n    try {\n      JSON.parse(value);\n    } catch (e) {\n      return false;\n    }\n\n    return true;\n  };\n  /**\n   * To destroy handlers in the event\n   *\n   * @returns {void} ?\n   */\n\n\n  Observer.prototype.destroy = function () {\n    this.boundedEvents = this.context = undefined;\n  };\n  /**\n   * Returns if the property exists.\n   *\n   * @param {string} prop ?\n   * @returns {boolean} ?\n   */\n\n\n  Observer.prototype.notExist = function (prop) {\n    // eslint-disable-next-line\n    return this.boundedEvents.hasOwnProperty(prop) === false || this.boundedEvents[prop].length <= 0;\n  };\n  /**\n   * Returns if the handler is present.\n   *\n   * @param {BoundOptions[]} boundedEvents ?\n   * @param {Function} handler ?\n   * @returns {boolean} ?\n   */\n\n\n  Observer.prototype.isHandlerPresent = function (boundedEvents, handler) {\n    for (var _i = 0, boundedEvents_1 = boundedEvents; _i < boundedEvents_1.length; _i++) {\n      var cur = boundedEvents_1[_i];\n\n      if (cur.handler === handler) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  return Observer;\n}();\n\nexport { Observer };","map":{"version":3,"sources":["C:/Users/khang/OneDrive/Tài liệu/JS/PersonalDashdoard/dashboard/node_modules/@syncfusion/ej2-react-inputs/node_modules/@syncfusion/ej2-base/src/observer.js"],"names":["isNullOrUndefined","getValue","extend","isBlazor","Observer","context","ranArray","boundedEvents","prototype","on","property","handler","id","cntxt","notExist","indexOf","push","isHandlerPresent","off","curObject","i","length","splice","indexLocation","notify","argument","successHandler","errorHandler","call","name","blazor","slice","window","blazorCallback","_i","curObject_1","cur","objs","index","_this","isTrigger","obj_1","promise","then","data","isJson","JSON","parse","dateReviver","catch","key","value","dPattern","match","Date","e","destroy","undefined","prop","hasOwnProperty","boundedEvents_1"],"mappings":"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","sourcesContent":["import { isNullOrUndefined, getValue, extend, isBlazor } from './util';\nvar Observer = /** @class */ (function () {\n    function Observer(context) {\n        this.ranArray = [];\n        this.boundedEvents = {};\n        if (isNullOrUndefined(context)) {\n            return;\n        }\n        this.context = context;\n    }\n    /**\n     * To attach handler for given property in current context.\n     *\n     * @param {string} property - specifies the name of the event.\n     * @param {Function} handler - Specifies the handler function to be called while event notified.\n     * @param {Object} context - Specifies the context binded to the handler.\n     * @param {string} id - specifies the random generated id.\n     * @returns {void}\n     */\n    Observer.prototype.on = function (property, handler, context, id) {\n        if (isNullOrUndefined(handler)) {\n            return;\n        }\n        var cntxt = context || this.context;\n        if (this.notExist(property)) {\n            this.boundedEvents[property] = [{ handler: handler, context: cntxt }];\n            return;\n        }\n        if (!isNullOrUndefined(id)) {\n            if (this.ranArray.indexOf(id) === -1) {\n                this.ranArray.push(id);\n                this.boundedEvents[property].push({ handler: handler, context: cntxt, id: id });\n            }\n        }\n        else if (!this.isHandlerPresent(this.boundedEvents[property], handler)) {\n            this.boundedEvents[property].push({ handler: handler, context: cntxt });\n        }\n    };\n    /**\n     * To remove handlers from a event attached using on() function.\n     *\n     * @param {string} property - specifies the name of the event.\n     * @param {Function} handler - Optional argument specifies the handler function to be called while event notified.\n     * @param {string} id - specifies the random generated id.\n     * @returns {void} ?\n     */\n    Observer.prototype.off = function (property, handler, id) {\n        if (this.notExist(property)) {\n            return;\n        }\n        var curObject = getValue(property, this.boundedEvents);\n        if (handler) {\n            for (var i = 0; i < curObject.length; i++) {\n                if (id) {\n                    if (curObject[i].id === id) {\n                        curObject.splice(i, 1);\n                        var indexLocation = this.ranArray.indexOf(id);\n                        if (indexLocation !== -1) {\n                            this.ranArray.splice(indexLocation, 1);\n                        }\n                        break;\n                    }\n                }\n                else if (handler === curObject[i].handler) {\n                    curObject.splice(i, 1);\n                    break;\n                }\n            }\n        }\n        else {\n            delete this.boundedEvents[property];\n        }\n    };\n    /**\n     * To notify the handlers in the specified event.\n     *\n     * @param {string} property - Specifies the event to be notify.\n     * @param {Object} argument - Additional parameters to pass while calling the handler.\n     * @param {Function} successHandler - this function will invoke after event successfully triggered\n     * @param {Function} errorHandler - this function will invoke after event if it was failure to call.\n     * @returns {void} ?\n     */\n    Observer.prototype.notify = function (property, argument, successHandler, errorHandler) {\n        if (this.notExist(property)) {\n            if (successHandler) {\n                successHandler.call(this, argument);\n            }\n            return;\n        }\n        if (argument) {\n            argument.name = property;\n        }\n        var blazor = 'Blazor';\n        var curObject = getValue(property, this.boundedEvents).slice(0);\n        if (window[blazor]) {\n            return this.blazorCallback(curObject, argument, successHandler, errorHandler, 0);\n        }\n        else {\n            for (var _i = 0, curObject_1 = curObject; _i < curObject_1.length; _i++) {\n                var cur = curObject_1[_i];\n                cur.handler.call(cur.context, argument);\n            }\n            if (successHandler) {\n                successHandler.call(this, argument);\n            }\n        }\n    };\n    Observer.prototype.blazorCallback = function (objs, argument, successHandler, errorHandler, index) {\n        var _this = this;\n        var isTrigger = index === objs.length - 1;\n        if (index < objs.length) {\n            var obj_1 = objs[index];\n            var promise = obj_1.handler.call(obj_1.context, argument);\n            if (promise && typeof promise.then === 'function') {\n                if (!successHandler) {\n                    return promise;\n                }\n                promise.then(function (data) {\n                    data = typeof data === 'string' && _this.isJson(data) ? JSON.parse(data, _this.dateReviver) : data;\n                    extend(argument, argument, data, true);\n                    if (successHandler && isTrigger) {\n                        successHandler.call(obj_1.context, argument);\n                    }\n                    else {\n                        return _this.blazorCallback(objs, argument, successHandler, errorHandler, index + 1);\n                    }\n                }).catch(function (data) {\n                    if (errorHandler) {\n                        errorHandler.call(obj_1.context, typeof data === 'string' &&\n                            _this.isJson(data) ? JSON.parse(data, _this.dateReviver) : data);\n                    }\n                });\n            }\n            else if (successHandler && isTrigger) {\n                successHandler.call(obj_1.context, argument);\n            }\n            else {\n                return this.blazorCallback(objs, argument, successHandler, errorHandler, index + 1);\n            }\n        }\n    };\n    // eslint-disable-next-line\n    Observer.prototype.dateReviver = function (key, value) {\n        var dPattern = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}/;\n        if (isBlazor && typeof value === 'string' && value.match(dPattern) !== null) {\n            return (new Date(value));\n        }\n        return (value);\n    };\n    Observer.prototype.isJson = function (value) {\n        try {\n            JSON.parse(value);\n        }\n        catch (e) {\n            return false;\n        }\n        return true;\n    };\n    /**\n     * To destroy handlers in the event\n     *\n     * @returns {void} ?\n     */\n    Observer.prototype.destroy = function () {\n        this.boundedEvents = this.context = undefined;\n    };\n    /**\n     * Returns if the property exists.\n     *\n     * @param {string} prop ?\n     * @returns {boolean} ?\n     */\n    Observer.prototype.notExist = function (prop) {\n        // eslint-disable-next-line\n        return this.boundedEvents.hasOwnProperty(prop) === false || this.boundedEvents[prop].length <= 0;\n    };\n    /**\n     * Returns if the handler is present.\n     *\n     * @param {BoundOptions[]} boundedEvents ?\n     * @param {Function} handler ?\n     * @returns {boolean} ?\n     */\n    Observer.prototype.isHandlerPresent = function (boundedEvents, handler) {\n        for (var _i = 0, boundedEvents_1 = boundedEvents; _i < boundedEvents_1.length; _i++) {\n            var cur = boundedEvents_1[_i];\n            if (cur.handler === handler) {\n                return true;\n            }\n        }\n        return false;\n    };\n    return Observer;\n}());\nexport { Observer };\n"]},"metadata":{},"sourceType":"module"}