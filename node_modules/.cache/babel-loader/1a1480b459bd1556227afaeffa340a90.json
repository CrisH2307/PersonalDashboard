{"ast":null,"code":"/**\n * Collision module.\n */\nimport { calculatePosition } from './position';\nimport { isNullOrUndefined } from '@syncfusion/ej2-base';\nvar parentDocument;\nvar targetContainer;\n/**\n *\n * @param {HTMLElement} element - specifies the element\n * @param {HTMLElement} viewPortElement - specifies the element\n * @param {CollisionCoordinates} axis - specifies the collision coordinates\n * @param {OffsetPosition} position - specifies the position\n * @returns {void}\n */\n\nexport function fit(element, viewPortElement, axis, position) {\n  if (viewPortElement === void 0) {\n    viewPortElement = null;\n  }\n\n  if (axis === void 0) {\n    axis = {\n      X: false,\n      Y: false\n    };\n  }\n\n  if (!axis.Y && !axis.X) {\n    return {\n      left: 0,\n      top: 0\n    };\n  }\n\n  var elemData = element.getBoundingClientRect();\n  targetContainer = viewPortElement;\n  parentDocument = element.ownerDocument;\n\n  if (!position) {\n    position = calculatePosition(element, 'left', 'top');\n  }\n\n  if (axis.X) {\n    var containerWidth = targetContainer ? getTargetContainerWidth() : getViewPortWidth();\n    var containerLeft = ContainerLeft();\n    var containerRight = ContainerRight();\n    var overLeft = containerLeft - position.left;\n    var overRight = position.left + elemData.width - containerRight;\n\n    if (elemData.width > containerWidth) {\n      if (overLeft > 0 && overRight <= 0) {\n        position.left = containerRight - elemData.width;\n      } else if (overRight > 0 && overLeft <= 0) {\n        position.left = containerLeft;\n      } else {\n        position.left = overLeft > overRight ? containerRight - elemData.width : containerLeft;\n      }\n    } else if (overLeft > 0) {\n      position.left += overLeft;\n    } else if (overRight > 0) {\n      position.left -= overRight;\n    }\n  }\n\n  if (axis.Y) {\n    var containerHeight = targetContainer ? getTargetContainerHeight() : getViewPortHeight();\n    var containerTop = ContainerTop();\n    var containerBottom = ContainerBottom();\n    var overTop = containerTop - position.top;\n    var overBottom = position.top + elemData.height - containerBottom;\n\n    if (elemData.height > containerHeight) {\n      if (overTop > 0 && overBottom <= 0) {\n        position.top = containerBottom - elemData.height;\n      } else if (overBottom > 0 && overTop <= 0) {\n        position.top = containerTop;\n      } else {\n        position.top = overTop > overBottom ? containerBottom - elemData.height : containerTop;\n      }\n    } else if (overTop > 0) {\n      position.top += overTop;\n    } else if (overBottom > 0) {\n      position.top -= overBottom;\n    }\n  }\n\n  return position;\n}\n/**\n *\n * @param {HTMLElement} element - specifies the html element\n * @param {HTMLElement} viewPortElement - specifies the html element\n * @param {number} x - specifies the number\n * @param {number} y - specifies the number\n * @returns {string[]} - returns the string value\n */\n\nexport function isCollide(element, viewPortElement, x, y) {\n  if (viewPortElement === void 0) {\n    viewPortElement = null;\n  }\n\n  var elemOffset = calculatePosition(element, 'left', 'top');\n\n  if (x) {\n    elemOffset.left = x;\n  }\n\n  if (y) {\n    elemOffset.top = y;\n  }\n\n  var data = [];\n  targetContainer = viewPortElement;\n  parentDocument = element.ownerDocument;\n  var elementRect = element.getBoundingClientRect();\n  var top = elemOffset.top;\n  var left = elemOffset.left;\n  var right = elemOffset.left + elementRect.width;\n  var bottom = elemOffset.top + elementRect.height; // eslint-disable-next-line\n\n  var topData = '',\n      leftData = '';\n  var yAxis = topCollideCheck(top, bottom);\n  var xAxis = leftCollideCheck(left, right);\n\n  if (yAxis.topSide) {\n    data.push('top');\n  }\n\n  if (xAxis.rightSide) {\n    data.push('right');\n  }\n\n  if (xAxis.leftSide) {\n    data.push('left');\n  }\n\n  if (yAxis.bottomSide) {\n    data.push('bottom');\n  }\n\n  return data;\n}\n/**\n *\n * @param {HTMLElement} element - specifies the element\n * @param {HTMLElement} target - specifies the element\n * @param {number} offsetX - specifies the number\n * @param {number} offsetY - specifies the number\n * @param {string} positionX - specifies the string value\n * @param {string} positionY - specifies the string value\n * @param {HTMLElement} viewPortElement - specifies the element\n * @param {CollisionCoordinates} axis - specifies the collision axis\n * @param {boolean} fixedParent - specifies the boolean\n * @returns {void}\n */\n\nexport function flip(element, target, offsetX, offsetY, positionX, positionY, viewPortElement,\n/* eslint-disable */\naxis, fixedParent) {\n  if (viewPortElement === void 0) {\n    viewPortElement = null;\n  }\n\n  if (axis === void 0) {\n    axis = {\n      X: true,\n      Y: true\n    };\n  }\n\n  if (!target || !element || !positionX || !positionY || !axis.X && !axis.Y) {\n    return;\n  } // eslint-disable-next-line\n\n\n  var tEdge = {\n    TL: null,\n    TR: null,\n    BL: null,\n    BR: null\n  },\n      eEdge = {\n    TL: null,\n    TR: null,\n    BL: null,\n    BR: null\n    /* eslint-enable */\n\n  };\n  var elementRect;\n\n  if (window.getComputedStyle(element).display === 'none') {\n    var oldVisibility = element.style.visibility;\n    element.style.visibility = 'hidden';\n    element.style.display = 'block';\n    elementRect = element.getBoundingClientRect();\n    element.style.removeProperty('display');\n    element.style.visibility = oldVisibility;\n  } else {\n    elementRect = element.getBoundingClientRect();\n  }\n\n  var pos = {\n    posX: positionX,\n    posY: positionY,\n    offsetX: offsetX,\n    offsetY: offsetY,\n    position: {\n      left: 0,\n      top: 0\n    }\n  };\n  targetContainer = viewPortElement;\n  parentDocument = target.ownerDocument;\n  updateElementData(target, tEdge, pos, fixedParent, elementRect);\n  setPosition(eEdge, pos, elementRect);\n\n  if (axis.X) {\n    leftFlip(target, eEdge, tEdge, pos, elementRect, true);\n  }\n\n  if (axis.Y && tEdge.TL.top > -1) {\n    topFlip(target, eEdge, tEdge, pos, elementRect, true);\n  }\n\n  setPopup(element, pos, elementRect);\n}\n/**\n *\n * @param {HTMLElement} element - specifies the element\n * @param {PositionLocation} pos - specifies the location\n * @param {ClientRect} elementRect - specifies the client rect\n * @returns {void}\n */\n\nfunction setPopup(element, pos, elementRect) {\n  //eslint-disable-next-line\n  var left = 0,\n      top = 0;\n\n  if (element.offsetParent != null && (getComputedStyle(element.offsetParent).position === 'absolute' || getComputedStyle(element.offsetParent).position === 'relative')) {\n    var data = calculatePosition(element.offsetParent, 'left', 'top', false, elementRect);\n    left = data.left;\n    top = data.top;\n  }\n\n  element.style.top = pos.position.top + pos.offsetY - top + 'px';\n  element.style.left = pos.position.left + pos.offsetX - left + 'px';\n}\n/**\n *\n * @param {HTMLElement} target - specifies the element\n * @param {EdgeOffset} edge - specifies the offset\n * @param {PositionLocation} pos - specifies theloaction\n * @param {boolean} fixedParent - specifies the boolean\n * @param {ClientRect} elementRect - specifies the client rect\n * @returns {void}\n */\n\n\nfunction updateElementData(target, edge, pos, fixedParent, elementRect) {\n  pos.position = calculatePosition(target, pos.posX, pos.posY, fixedParent, elementRect);\n  edge.TL = calculatePosition(target, 'left', 'top', fixedParent, elementRect);\n  edge.TR = calculatePosition(target, 'right', 'top', fixedParent, elementRect);\n  edge.BR = calculatePosition(target, 'left', 'bottom', fixedParent, elementRect);\n  edge.BL = calculatePosition(target, 'right', 'bottom', fixedParent, elementRect);\n}\n/**\n *\n * @param {EdgeOffset} eStatus - specifies the status\n * @param {PositionLocation} pos - specifies the location\n * @param {ClientRect} elementRect - specifies the client\n * @returns {void}\n */\n\n\nfunction setPosition(eStatus, pos, elementRect) {\n  eStatus.TL = {\n    top: pos.position.top + pos.offsetY,\n    left: pos.position.left + pos.offsetX\n  };\n  eStatus.TR = {\n    top: eStatus.TL.top,\n    left: eStatus.TL.left + elementRect.width\n  };\n  eStatus.BL = {\n    top: eStatus.TL.top + elementRect.height,\n    left: eStatus.TL.left\n  };\n  eStatus.BR = {\n    top: eStatus.TL.top + elementRect.height,\n    left: eStatus.TL.left + elementRect.width\n  };\n}\n/**\n *\n * @param {number} left - specifies the  number\n * @param {number} right - specifies the number\n * @returns {LeftCorners} - returns the value\n */\n\n\nfunction leftCollideCheck(left, right) {\n  //eslint-disable-next-line\n  var leftSide = false,\n      rightSide = false;\n\n  if (left - getBodyScrollLeft() < ContainerLeft()) {\n    leftSide = true;\n  }\n\n  if (right > ContainerRight()) {\n    rightSide = true;\n  }\n\n  return {\n    leftSide: leftSide,\n    rightSide: rightSide\n  };\n}\n/**\n *\n * @param {HTMLElement} target - specifies the element\n * @param {EdgeOffset} edge - specifes the element\n * @param {EdgeOffset} tEdge - specifies the edge offset\n * @param {PositionLocation} pos - specifes the location\n * @param {ClientRect} elementRect - specifies the client\n * @param {boolean} deepCheck - specifies the boolean value\n * @returns {void}\n */\n\n\nfunction leftFlip(target, edge, tEdge, pos, elementRect, deepCheck) {\n  var collideSide = leftCollideCheck(edge.TL.left, edge.TR.left);\n\n  if (tEdge.TL.left - getBodyScrollLeft() <= ContainerLeft()) {\n    collideSide.leftSide = false;\n  }\n\n  if (tEdge.TR.left > ContainerRight()) {\n    collideSide.rightSide = false;\n  }\n\n  if (collideSide.leftSide && !collideSide.rightSide || !collideSide.leftSide && collideSide.rightSide) {\n    if (pos.posX === 'right') {\n      pos.posX = 'left';\n    } else {\n      pos.posX = 'right';\n    }\n\n    pos.offsetX = pos.offsetX + elementRect.width;\n    pos.offsetX = -1 * pos.offsetX;\n    pos.position = calculatePosition(target, pos.posX, pos.posY, false);\n    setPosition(edge, pos, elementRect);\n\n    if (deepCheck) {\n      leftFlip(target, edge, tEdge, pos, elementRect, false);\n    }\n  }\n}\n/**\n *\n * @param {HTMLElement} target - specifies the element\n * @param {EdgeOffset} edge - specifies the offset\n * @param {EdgeOffset} tEdge - specifies the offset\n * @param {PositionLocation} pos - specifies the location\n * @param {ClientRect} elementRect - specifies the client rect\n * @param {boolean} deepCheck - specifies the boolean\n * @returns {void}\n */\n\n\nfunction topFlip(target, edge, tEdge, pos, elementRect, deepCheck) {\n  var collideSide = topCollideCheck(edge.TL.top, edge.BL.top);\n\n  if (tEdge.TL.top - getBodyScrollTop() <= ContainerTop()) {\n    collideSide.topSide = false;\n  }\n\n  if (tEdge.BL.top >= ContainerBottom() && target.getBoundingClientRect().bottom < window.innerHeight) {\n    collideSide.bottomSide = false;\n  }\n\n  if (collideSide.topSide && !collideSide.bottomSide || !collideSide.topSide && collideSide.bottomSide) {\n    if (pos.posY === 'top') {\n      pos.posY = 'bottom';\n    } else {\n      pos.posY = 'top';\n    }\n\n    pos.offsetY = pos.offsetY + elementRect.height;\n    pos.offsetY = -1 * pos.offsetY;\n    pos.position = calculatePosition(target, pos.posX, pos.posY, false, elementRect);\n    setPosition(edge, pos, elementRect);\n\n    if (deepCheck) {\n      topFlip(target, edge, tEdge, pos, elementRect, false);\n    }\n  }\n}\n/**\n *\n * @param {number} top - specifies the number\n * @param {number} bottom - specifies the number\n * @returns {TopCorners} - retyrns the value\n */\n\n\nfunction topCollideCheck(top, bottom) {\n  //eslint-disable-next-line\n  var topSide = false,\n      bottomSide = false;\n\n  if (top - getBodyScrollTop() < ContainerTop()) {\n    topSide = true;\n  }\n\n  if (bottom > ContainerBottom()) {\n    bottomSide = true;\n  }\n\n  return {\n    topSide: topSide,\n    bottomSide: bottomSide\n  };\n}\n/**\n * @returns {void}\n */\n\n\nfunction getTargetContainerWidth() {\n  return targetContainer.getBoundingClientRect().width;\n}\n/**\n * @returns {void}\n */\n\n\nfunction getTargetContainerHeight() {\n  return targetContainer.getBoundingClientRect().height;\n}\n/**\n * @returns {void}\n */\n\n\nfunction getTargetContainerLeft() {\n  return targetContainer.getBoundingClientRect().left;\n}\n/**\n * @returns {void}\n */\n\n\nfunction getTargetContainerTop() {\n  return targetContainer.getBoundingClientRect().top;\n} //eslint-disable-next-line\n\n\nfunction ContainerTop() {\n  if (targetContainer) {\n    return getTargetContainerTop();\n  }\n\n  return 0;\n} //eslint-disable-next-line\n\n\nfunction ContainerLeft() {\n  if (targetContainer) {\n    return getTargetContainerLeft();\n  }\n\n  return 0;\n} //eslint-disable-next-line\n\n\nfunction ContainerRight() {\n  if (targetContainer) {\n    return getBodyScrollLeft() + getTargetContainerLeft() + getTargetContainerWidth();\n  }\n\n  return getBodyScrollLeft() + getViewPortWidth();\n} //eslint-disable-next-line\n\n\nfunction ContainerBottom() {\n  if (targetContainer) {\n    return getBodyScrollTop() + getTargetContainerTop() + getTargetContainerHeight();\n  }\n\n  return getBodyScrollTop() + getViewPortHeight();\n}\n/**\n * @returns {void}\n */\n\n\nfunction getBodyScrollTop() {\n  // if(targetContainer)\n  //     return targetContainer.scrollTop;\n  return parentDocument.documentElement.scrollTop || parentDocument.body.scrollTop;\n}\n/**\n * @returns {void}\n */\n\n\nfunction getBodyScrollLeft() {\n  // if(targetContainer)\n  //     return targetContainer.scrollLeft;\n  return parentDocument.documentElement.scrollLeft || parentDocument.body.scrollLeft;\n}\n/**\n * @returns {void}\n */\n\n\nfunction getViewPortHeight() {\n  return window.innerHeight;\n}\n/**\n * @returns {void}\n */\n\n\nfunction getViewPortWidth() {\n  var windowWidth = window.innerWidth;\n  var documentReact = document.documentElement.getBoundingClientRect();\n  var offsetWidth = isNullOrUndefined(document.documentElement) ? 0 : documentReact.width;\n  return windowWidth - (windowWidth - offsetWidth);\n}","map":{"version":3,"sources":["C:/Users/khang/OneDrive/Tài liệu/JS/PersonalDashdoard/dashboard/node_modules/@syncfusion/ej2-react-richtexteditor/node_modules/@syncfusion/ej2-popups/src/common/collision.js"],"names":["calculatePosition","isNullOrUndefined","parentDocument","targetContainer","fit","element","viewPortElement","axis","position","X","Y","left","top","elemData","getBoundingClientRect","ownerDocument","containerWidth","getTargetContainerWidth","getViewPortWidth","containerLeft","ContainerLeft","containerRight","ContainerRight","overLeft","overRight","width","containerHeight","getTargetContainerHeight","getViewPortHeight","containerTop","ContainerTop","containerBottom","ContainerBottom","overTop","overBottom","height","isCollide","x","y","elemOffset","data","elementRect","right","bottom","topData","leftData","yAxis","topCollideCheck","xAxis","leftCollideCheck","topSide","push","rightSide","leftSide","bottomSide","flip","target","offsetX","offsetY","positionX","positionY","fixedParent","tEdge","TL","TR","BL","BR","eEdge","window","getComputedStyle","display","oldVisibility","style","visibility","removeProperty","pos","posX","posY","updateElementData","setPosition","leftFlip","topFlip","setPopup","offsetParent","edge","eStatus","getBodyScrollLeft","deepCheck","collideSide","getBodyScrollTop","innerHeight","getTargetContainerLeft","getTargetContainerTop","documentElement","scrollTop","body","scrollLeft","windowWidth","innerWidth","documentReact","document","offsetWidth"],"mappings":"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","sourcesContent":["/**\n * Collision module.\n */\nimport { calculatePosition } from './position';\nimport { isNullOrUndefined } from '@syncfusion/ej2-base';\nvar parentDocument;\nvar targetContainer;\n/**\n *\n * @param {HTMLElement} element - specifies the element\n * @param {HTMLElement} viewPortElement - specifies the element\n * @param {CollisionCoordinates} axis - specifies the collision coordinates\n * @param {OffsetPosition} position - specifies the position\n * @returns {void}\n */\nexport function fit(element, viewPortElement, axis, position) {\n    if (viewPortElement === void 0) { viewPortElement = null; }\n    if (axis === void 0) { axis = { X: false, Y: false }; }\n    if (!axis.Y && !axis.X) {\n        return { left: 0, top: 0 };\n    }\n    var elemData = element.getBoundingClientRect();\n    targetContainer = viewPortElement;\n    parentDocument = element.ownerDocument;\n    if (!position) {\n        position = calculatePosition(element, 'left', 'top');\n    }\n    if (axis.X) {\n        var containerWidth = targetContainer ? getTargetContainerWidth() : getViewPortWidth();\n        var containerLeft = ContainerLeft();\n        var containerRight = ContainerRight();\n        var overLeft = containerLeft - position.left;\n        var overRight = position.left + elemData.width - containerRight;\n        if (elemData.width > containerWidth) {\n            if (overLeft > 0 && overRight <= 0) {\n                position.left = containerRight - elemData.width;\n            }\n            else if (overRight > 0 && overLeft <= 0) {\n                position.left = containerLeft;\n            }\n            else {\n                position.left = overLeft > overRight ? (containerRight - elemData.width) : containerLeft;\n            }\n        }\n        else if (overLeft > 0) {\n            position.left += overLeft;\n        }\n        else if (overRight > 0) {\n            position.left -= overRight;\n        }\n    }\n    if (axis.Y) {\n        var containerHeight = targetContainer ? getTargetContainerHeight() : getViewPortHeight();\n        var containerTop = ContainerTop();\n        var containerBottom = ContainerBottom();\n        var overTop = containerTop - position.top;\n        var overBottom = position.top + elemData.height - containerBottom;\n        if (elemData.height > containerHeight) {\n            if (overTop > 0 && overBottom <= 0) {\n                position.top = containerBottom - elemData.height;\n            }\n            else if (overBottom > 0 && overTop <= 0) {\n                position.top = containerTop;\n            }\n            else {\n                position.top = overTop > overBottom ? (containerBottom - elemData.height) : containerTop;\n            }\n        }\n        else if (overTop > 0) {\n            position.top += overTop;\n        }\n        else if (overBottom > 0) {\n            position.top -= overBottom;\n        }\n    }\n    return position;\n}\n/**\n *\n * @param {HTMLElement} element - specifies the html element\n * @param {HTMLElement} viewPortElement - specifies the html element\n * @param {number} x - specifies the number\n * @param {number} y - specifies the number\n * @returns {string[]} - returns the string value\n */\nexport function isCollide(element, viewPortElement, x, y) {\n    if (viewPortElement === void 0) { viewPortElement = null; }\n    var elemOffset = calculatePosition(element, 'left', 'top');\n    if (x) {\n        elemOffset.left = x;\n    }\n    if (y) {\n        elemOffset.top = y;\n    }\n    var data = [];\n    targetContainer = viewPortElement;\n    parentDocument = element.ownerDocument;\n    var elementRect = element.getBoundingClientRect();\n    var top = elemOffset.top;\n    var left = elemOffset.left;\n    var right = elemOffset.left + elementRect.width;\n    var bottom = elemOffset.top + elementRect.height;\n    // eslint-disable-next-line\n    var topData = '', leftData = '';\n    var yAxis = topCollideCheck(top, bottom);\n    var xAxis = leftCollideCheck(left, right);\n    if (yAxis.topSide) {\n        data.push('top');\n    }\n    if (xAxis.rightSide) {\n        data.push('right');\n    }\n    if (xAxis.leftSide) {\n        data.push('left');\n    }\n    if (yAxis.bottomSide) {\n        data.push('bottom');\n    }\n    return data;\n}\n/**\n *\n * @param {HTMLElement} element - specifies the element\n * @param {HTMLElement} target - specifies the element\n * @param {number} offsetX - specifies the number\n * @param {number} offsetY - specifies the number\n * @param {string} positionX - specifies the string value\n * @param {string} positionY - specifies the string value\n * @param {HTMLElement} viewPortElement - specifies the element\n * @param {CollisionCoordinates} axis - specifies the collision axis\n * @param {boolean} fixedParent - specifies the boolean\n * @returns {void}\n */\nexport function flip(element, target, offsetX, offsetY, positionX, positionY, viewPortElement, \n/* eslint-disable */\naxis, fixedParent) {\n    if (viewPortElement === void 0) { viewPortElement = null; }\n    if (axis === void 0) { axis = { X: true, Y: true }; }\n    if (!target || !element || !positionX || !positionY || (!axis.X && !axis.Y)) {\n        return;\n    }\n    // eslint-disable-next-line\n    var tEdge = { TL: null,\n        TR: null,\n        BL: null,\n        BR: null\n    }, eEdge = {\n        TL: null,\n        TR: null,\n        BL: null,\n        BR: null\n        /* eslint-enable */\n    };\n    var elementRect;\n    if (window.getComputedStyle(element).display === 'none') {\n        var oldVisibility = element.style.visibility;\n        element.style.visibility = 'hidden';\n        element.style.display = 'block';\n        elementRect = element.getBoundingClientRect();\n        element.style.removeProperty('display');\n        element.style.visibility = oldVisibility;\n    }\n    else {\n        elementRect = element.getBoundingClientRect();\n    }\n    var pos = {\n        posX: positionX, posY: positionY, offsetX: offsetX, offsetY: offsetY, position: { left: 0, top: 0 }\n    };\n    targetContainer = viewPortElement;\n    parentDocument = target.ownerDocument;\n    updateElementData(target, tEdge, pos, fixedParent, elementRect);\n    setPosition(eEdge, pos, elementRect);\n    if (axis.X) {\n        leftFlip(target, eEdge, tEdge, pos, elementRect, true);\n    }\n    if (axis.Y && tEdge.TL.top > -1) {\n        topFlip(target, eEdge, tEdge, pos, elementRect, true);\n    }\n    setPopup(element, pos, elementRect);\n}\n/**\n *\n * @param {HTMLElement} element - specifies the element\n * @param {PositionLocation} pos - specifies the location\n * @param {ClientRect} elementRect - specifies the client rect\n * @returns {void}\n */\nfunction setPopup(element, pos, elementRect) {\n    //eslint-disable-next-line\n    var left = 0, top = 0;\n    if (element.offsetParent != null\n        && (getComputedStyle(element.offsetParent).position === 'absolute' ||\n            getComputedStyle(element.offsetParent).position === 'relative')) {\n        var data = calculatePosition(element.offsetParent, 'left', 'top', false, elementRect);\n        left = data.left;\n        top = data.top;\n    }\n    element.style.top = (pos.position.top + pos.offsetY - (top)) + 'px';\n    element.style.left = (pos.position.left + pos.offsetX - (left)) + 'px';\n}\n/**\n *\n * @param {HTMLElement} target - specifies the element\n * @param {EdgeOffset} edge - specifies the offset\n * @param {PositionLocation} pos - specifies theloaction\n * @param {boolean} fixedParent - specifies the boolean\n * @param {ClientRect} elementRect - specifies the client rect\n * @returns {void}\n */\nfunction updateElementData(target, edge, pos, fixedParent, elementRect) {\n    pos.position = calculatePosition(target, pos.posX, pos.posY, fixedParent, elementRect);\n    edge.TL = calculatePosition(target, 'left', 'top', fixedParent, elementRect);\n    edge.TR = calculatePosition(target, 'right', 'top', fixedParent, elementRect);\n    edge.BR = calculatePosition(target, 'left', 'bottom', fixedParent, elementRect);\n    edge.BL = calculatePosition(target, 'right', 'bottom', fixedParent, elementRect);\n}\n/**\n *\n * @param {EdgeOffset} eStatus - specifies the status\n * @param {PositionLocation} pos - specifies the location\n * @param {ClientRect} elementRect - specifies the client\n * @returns {void}\n */\nfunction setPosition(eStatus, pos, elementRect) {\n    eStatus.TL = { top: pos.position.top + pos.offsetY, left: pos.position.left + pos.offsetX };\n    eStatus.TR = { top: eStatus.TL.top, left: eStatus.TL.left + elementRect.width };\n    eStatus.BL = { top: eStatus.TL.top + elementRect.height,\n        left: eStatus.TL.left };\n    eStatus.BR = { top: eStatus.TL.top + elementRect.height,\n        left: eStatus.TL.left + elementRect.width };\n}\n/**\n *\n * @param {number} left - specifies the  number\n * @param {number} right - specifies the number\n * @returns {LeftCorners} - returns the value\n */\nfunction leftCollideCheck(left, right) {\n    //eslint-disable-next-line\n    var leftSide = false, rightSide = false;\n    if (((left - getBodyScrollLeft()) < ContainerLeft())) {\n        leftSide = true;\n    }\n    if (right > ContainerRight()) {\n        rightSide = true;\n    }\n    return { leftSide: leftSide, rightSide: rightSide };\n}\n/**\n *\n * @param {HTMLElement} target - specifies the element\n * @param {EdgeOffset} edge - specifes the element\n * @param {EdgeOffset} tEdge - specifies the edge offset\n * @param {PositionLocation} pos - specifes the location\n * @param {ClientRect} elementRect - specifies the client\n * @param {boolean} deepCheck - specifies the boolean value\n * @returns {void}\n */\nfunction leftFlip(target, edge, tEdge, pos, elementRect, deepCheck) {\n    var collideSide = leftCollideCheck(edge.TL.left, edge.TR.left);\n    if ((tEdge.TL.left - getBodyScrollLeft()) <= ContainerLeft()) {\n        collideSide.leftSide = false;\n    }\n    if (tEdge.TR.left > ContainerRight()) {\n        collideSide.rightSide = false;\n    }\n    if ((collideSide.leftSide && !collideSide.rightSide) || (!collideSide.leftSide && collideSide.rightSide)) {\n        if (pos.posX === 'right') {\n            pos.posX = 'left';\n        }\n        else {\n            pos.posX = 'right';\n        }\n        pos.offsetX = pos.offsetX + elementRect.width;\n        pos.offsetX = -1 * pos.offsetX;\n        pos.position = calculatePosition(target, pos.posX, pos.posY, false);\n        setPosition(edge, pos, elementRect);\n        if (deepCheck) {\n            leftFlip(target, edge, tEdge, pos, elementRect, false);\n        }\n    }\n}\n/**\n *\n * @param {HTMLElement} target - specifies the element\n * @param {EdgeOffset} edge - specifies the offset\n * @param {EdgeOffset} tEdge - specifies the offset\n * @param {PositionLocation} pos - specifies the location\n * @param {ClientRect} elementRect - specifies the client rect\n * @param {boolean} deepCheck - specifies the boolean\n * @returns {void}\n */\nfunction topFlip(target, edge, tEdge, pos, elementRect, deepCheck) {\n    var collideSide = topCollideCheck(edge.TL.top, edge.BL.top);\n    if ((tEdge.TL.top - getBodyScrollTop()) <= ContainerTop()) {\n        collideSide.topSide = false;\n    }\n    if (tEdge.BL.top >= ContainerBottom() && target.getBoundingClientRect().bottom < window.innerHeight) {\n        collideSide.bottomSide = false;\n    }\n    if ((collideSide.topSide && !collideSide.bottomSide) || (!collideSide.topSide && collideSide.bottomSide)) {\n        if (pos.posY === 'top') {\n            pos.posY = 'bottom';\n        }\n        else {\n            pos.posY = 'top';\n        }\n        pos.offsetY = pos.offsetY + elementRect.height;\n        pos.offsetY = -1 * pos.offsetY;\n        pos.position = calculatePosition(target, pos.posX, pos.posY, false, elementRect);\n        setPosition(edge, pos, elementRect);\n        if (deepCheck) {\n            topFlip(target, edge, tEdge, pos, elementRect, false);\n        }\n    }\n}\n/**\n *\n * @param {number} top - specifies the number\n * @param {number} bottom - specifies the number\n * @returns {TopCorners} - retyrns the value\n */\nfunction topCollideCheck(top, bottom) {\n    //eslint-disable-next-line\n    var topSide = false, bottomSide = false;\n    if ((top - getBodyScrollTop()) < ContainerTop()) {\n        topSide = true;\n    }\n    if (bottom > ContainerBottom()) {\n        bottomSide = true;\n    }\n    return { topSide: topSide, bottomSide: bottomSide };\n}\n/**\n * @returns {void}\n */\nfunction getTargetContainerWidth() {\n    return targetContainer.getBoundingClientRect().width;\n}\n/**\n * @returns {void}\n */\nfunction getTargetContainerHeight() {\n    return targetContainer.getBoundingClientRect().height;\n}\n/**\n * @returns {void}\n */\nfunction getTargetContainerLeft() {\n    return targetContainer.getBoundingClientRect().left;\n}\n/**\n * @returns {void}\n */\nfunction getTargetContainerTop() {\n    return targetContainer.getBoundingClientRect().top;\n}\n//eslint-disable-next-line\nfunction ContainerTop() {\n    if (targetContainer) {\n        return getTargetContainerTop();\n    }\n    return 0;\n}\n//eslint-disable-next-line\nfunction ContainerLeft() {\n    if (targetContainer) {\n        return getTargetContainerLeft();\n    }\n    return 0;\n}\n//eslint-disable-next-line\nfunction ContainerRight() {\n    if (targetContainer) {\n        return (getBodyScrollLeft() + getTargetContainerLeft() + getTargetContainerWidth());\n    }\n    return (getBodyScrollLeft() + getViewPortWidth());\n}\n//eslint-disable-next-line\nfunction ContainerBottom() {\n    if (targetContainer) {\n        return (getBodyScrollTop() + getTargetContainerTop() + getTargetContainerHeight());\n    }\n    return (getBodyScrollTop() + getViewPortHeight());\n}\n/**\n * @returns {void}\n */\nfunction getBodyScrollTop() {\n    // if(targetContainer)\n    //     return targetContainer.scrollTop;\n    return parentDocument.documentElement.scrollTop || parentDocument.body.scrollTop;\n}\n/**\n * @returns {void}\n */\nfunction getBodyScrollLeft() {\n    // if(targetContainer)\n    //     return targetContainer.scrollLeft;\n    return parentDocument.documentElement.scrollLeft || parentDocument.body.scrollLeft;\n}\n/**\n * @returns {void}\n */\nfunction getViewPortHeight() {\n    return window.innerHeight;\n}\n/**\n * @returns {void}\n */\nfunction getViewPortWidth() {\n    var windowWidth = window.innerWidth;\n    var documentReact = document.documentElement.getBoundingClientRect();\n    var offsetWidth = (isNullOrUndefined(document.documentElement)) ? 0 : documentReact.width;\n    return windowWidth - (windowWidth - offsetWidth);\n}\n"]},"metadata":{},"sourceType":"module"}