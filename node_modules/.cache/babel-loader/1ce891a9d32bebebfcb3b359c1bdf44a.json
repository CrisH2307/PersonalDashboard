{"ast":null,"code":"/* eslint-disable no-trailing-spaces */\n\n/* eslint-disable @typescript-eslint/ban-types */\n\n/* eslint-disable @typescript-eslint/no-inferrable-types */\n\n/* eslint-disable jsdoc/require-returns */\n\n/* eslint-disable valid-jsdoc */\n\n/* eslint-disable jsdoc/require-param */\nimport { getAnimationFunction, pathAnimation, getElement } from '../../common/utils/helper';\nimport { Rect } from '@syncfusion/ej2-svg-base';\nimport { Animation, isNullOrUndefined } from '@syncfusion/ej2-base';\n/**\n * Base for line type series.\n */\n\nvar LineBase =\n/** @class */\nfunction () {\n  /** @private */\n  function LineBase(chartModule) {\n    this.chart = chartModule;\n  }\n  /**\n   * To improve the chart performance.\n   *\n   * @returns {void}\n   * @private\n   */\n\n\n  LineBase.prototype.enableComplexProperty = function (series) {\n    var tempPoints = [];\n    var tempPoints2 = [];\n    var xVisibleRange = series.xAxis.visibleRange;\n    var yVisibleRange = series.yAxis.visibleRange;\n    var seriesPoints = series.points;\n    var areaBounds = series.clipRect;\n    var xTolerance = Math.abs(xVisibleRange.delta / areaBounds.width);\n    var yTolerance = Math.abs(yVisibleRange.delta / areaBounds.height);\n    var prevXValue = seriesPoints[0] && seriesPoints[0].x > xTolerance ? 0 : xTolerance;\n    var prevYValue = seriesPoints[0] && seriesPoints[0].y > yTolerance ? 0 : yTolerance;\n    var xVal = 0;\n    var yVal = 0;\n\n    for (var _i = 0, seriesPoints_1 = seriesPoints; _i < seriesPoints_1.length; _i++) {\n      var currentPoint = seriesPoints_1[_i];\n      currentPoint.symbolLocations = [];\n      xVal = currentPoint.xValue ? currentPoint.xValue : xVisibleRange.min;\n      yVal = currentPoint.yValue ? currentPoint.yValue : yVisibleRange.min;\n\n      if (Math.abs(prevXValue - xVal) >= xTolerance || Math.abs(prevYValue - yVal) >= yTolerance) {\n        tempPoints.push(currentPoint);\n        prevXValue = xVal;\n        prevYValue = yVal;\n      }\n    }\n\n    var tempPoint;\n\n    for (var i = 0; i < tempPoints.length; i++) {\n      tempPoint = tempPoints[i];\n\n      if (isNullOrUndefined(tempPoint.x) || tempPoint.x === '' || series.category === 'Indicator' && (isNaN(tempPoint.xValue) || isNaN(tempPoint.yValue))) {\n        continue;\n      } else {\n        tempPoints2.push(tempPoint);\n      }\n    }\n\n    return tempPoints2;\n  };\n  /**\n   * To generate the line path direction\n   *\n   * @param {Points} firstPoint firstPoint\n   * @param {Points} secondPoint secondPoint\n   * @param {Series} series series\n   * @param {boolean} isInverted isInverted\n   * @param {Function} getPointLocation getPointLocation\n   * @param {string} startPoint startPoint\n   */\n\n\n  LineBase.prototype.getLineDirection = function (firstPoint, secondPoint, series, isInverted, getPointLocation, startPoint) {\n    var direction = '';\n\n    if (firstPoint != null) {\n      var point1 = getPointLocation(firstPoint.xValue, firstPoint.yValue, series.xAxis, series.yAxis, isInverted, series);\n      var point2 = getPointLocation(secondPoint.xValue, secondPoint.yValue, series.xAxis, series.yAxis, isInverted, series);\n      direction = startPoint + ' ' + point1.x + ' ' + point1.y + ' ' + 'L' + ' ' + point2.x + ' ' + point2.y + ' ';\n    }\n\n    return direction;\n  };\n  /**\n   * To append the line path.\n   *\n   * @returns {void}\n   * @private\n   */\n\n\n  LineBase.prototype.appendLinePath = function (options, series, clipRect) {\n    var element = getElement(options.id);\n    var chart = series.chart;\n    var previousDirection = element ? element.getAttribute('d') : null;\n    var htmlObject = series.chart.renderer.drawPath(options, new Int32Array([series.clipRect.x, series.clipRect.y]));\n\n    if (htmlObject) {\n      htmlObject.setAttribute('clip-path', clipRect);\n    }\n\n    series.pathElement = htmlObject;\n\n    if (!series.chart.enableCanvas) {\n      series.seriesElement.appendChild(htmlObject);\n    }\n\n    series.isRectSeries = false;\n    pathAnimation(element, options.d, series.chart.redraw, previousDirection, chart.duration);\n  };\n  /**\n   * To render the marker for the series.\n   *\n   * @returns {void}\n   * @private\n   */\n\n\n  LineBase.prototype.renderMarker = function (series) {\n    if (series.marker && series.marker.visible) {\n      series.chart.markerRender.render(series);\n    }\n  };\n  /**\n   * To do the progressive animation.\n   *\n   * @returns {void}\n   * @private\n   */\n\n\n  LineBase.prototype.doProgressiveAnimation = function (series, option) {\n    var animation = new Animation({});\n    var path = series.pathElement;\n    var strokeDashArray = path.getAttribute('stroke-dasharray');\n    var pathLength = series.pathElement.getTotalLength();\n    var currentTime;\n    path.style.visibility = 'hidden';\n    animation.animate(path, {\n      duration: option.duration,\n      delay: option.delay,\n      progress: function (args) {\n        if (args.timeStamp >= args.delay) {\n          path.style.visibility = 'visible';\n          currentTime = Math.abs(Math.round((args.timeStamp - args.delay) * pathLength / args.duration));\n          path.setAttribute('stroke-dasharray', currentTime + ',' + pathLength);\n        }\n      },\n      end: function () {\n        path.setAttribute('stroke-dasharray', strokeDashArray);\n        series.chart.trigger('animationComplete', {\n          series: series.chart.isBlazor ? {} : series\n        });\n      }\n    });\n  };\n  /**\n   * To store the symbol location and region\n   *\n   * @param {Points} point point\n   * @param {Series} series series\n   * @param {boolean} isInverted isInverted\n   * @param {Function} getLocation getLocation\n   */\n\n\n  LineBase.prototype.storePointLocation = function (point, series, isInverted, getLocation) {\n    var markerWidth = series.marker && series.marker.width ? series.marker.width : 0;\n    var markerHeight = series.marker && series.marker.height ? series.marker.height : 0;\n    point.symbolLocations.push(getLocation(point.xValue, point.yValue, series.xAxis, series.yAxis, isInverted, series));\n    point.regions.push(new Rect(point.symbolLocations[0].x - markerWidth, point.symbolLocations[0].y - markerHeight, 2 * markerWidth, 2 * markerHeight));\n  };\n  /**\n   * To find point with in the visible range\n   *\n   * @param {Points} point point\n   * @param {Axis} yAxis yAxis\n   * @private\n   */\n\n\n  LineBase.prototype.withinYRange = function (point, yAxis) {\n    return point.yValue >= yAxis.visibleRange.min && point.yValue <= yAxis.visibleRange.max;\n  };\n  /**\n   * To get first and last visible points\n   *\n   * @private\n   */\n\n\n  LineBase.prototype.getFirstLastVisiblePoint = function (points) {\n    var first = null;\n    var last = null;\n\n    for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {\n      var point = points_1[_i];\n\n      if (first === null && point.visible) {\n        first = last = point;\n      }\n\n      last = point.visible ? point : last;\n    }\n\n    return {\n      first: first ? first : points[0],\n      last: last ? last : points[points.length - 1]\n    };\n  };\n  /**\n   * To do the linear animation.\n   *\n   * @returns {void}\n   * @private\n   */\n\n\n  LineBase.prototype.doLinearAnimation = function (series, animation) {\n    var clipRect = series.clipRectElement.childNodes[0].childNodes[0];\n    var duration = series.chart.animated ? series.chart.duration : animation.duration;\n    var effect = getAnimationFunction('Linear');\n    var elementHeight = +clipRect.getAttribute('height');\n    var elementWidth = +clipRect.getAttribute('width');\n    var xCenter = +clipRect.getAttribute('x');\n    var yCenter = series.chart.requireInvertedAxis ? +clipRect.getAttribute('height') + +clipRect.getAttribute('y') : +clipRect.getAttribute('y');\n    var value;\n    clipRect.style.visibility = 'hidden';\n    new Animation({}).animate(clipRect, {\n      duration: duration,\n      delay: animation.delay,\n      progress: function (args) {\n        if (args.timeStamp >= args.delay) {\n          clipRect.style.visibility = 'visible';\n\n          if (series.chart.requireInvertedAxis) {\n            value = effect(args.timeStamp - args.delay, 0, elementHeight, args.duration);\n            clipRect.setAttribute('transform', 'translate(' + xCenter + ' ' + yCenter + ') scale(1,' + value / elementHeight + ') translate(' + -xCenter + ' ' + -yCenter + ')');\n          } else {\n            value = effect(args.timeStamp - args.delay, 0, elementWidth, args.duration);\n            clipRect.setAttribute('transform', 'translate(' + xCenter + ' ' + yCenter + ') scale(' + value / elementWidth + ', 1) translate(' + -xCenter + ' ' + -yCenter + ')');\n          }\n        }\n      },\n      end: function () {\n        clipRect.setAttribute('transform', 'translate(0,0)');\n        series.chart.trigger('animationComplete', {\n          series: series.chart.isBlazor ? {} : series\n        });\n      }\n    });\n  };\n\n  return LineBase;\n}();\n\nexport { LineBase };","map":{"version":3,"sources":["C:/Users/khang/OneDrive/Tài liệu/JS/PersonalDashdoard/dashboard/node_modules/@syncfusion/ej2-react-charts/node_modules/@syncfusion/ej2-charts/src/chart/series/line-base.js"],"names":["getAnimationFunction","pathAnimation","getElement","Rect","Animation","isNullOrUndefined","LineBase","chartModule","chart","prototype","enableComplexProperty","series","tempPoints","tempPoints2","xVisibleRange","xAxis","visibleRange","yVisibleRange","yAxis","seriesPoints","points","areaBounds","clipRect","xTolerance","Math","abs","delta","width","yTolerance","height","prevXValue","x","prevYValue","y","xVal","yVal","_i","seriesPoints_1","length","currentPoint","symbolLocations","xValue","min","yValue","push","tempPoint","i","category","isNaN","getLineDirection","firstPoint","secondPoint","isInverted","getPointLocation","startPoint","direction","point1","point2","appendLinePath","options","element","id","previousDirection","getAttribute","htmlObject","renderer","drawPath","Int32Array","setAttribute","pathElement","enableCanvas","seriesElement","appendChild","isRectSeries","d","redraw","duration","renderMarker","marker","visible","markerRender","render","doProgressiveAnimation","option","animation","path","strokeDashArray","pathLength","getTotalLength","currentTime","style","visibility","animate","delay","progress","args","timeStamp","round","end","trigger","isBlazor","storePointLocation","point","getLocation","markerWidth","markerHeight","regions","withinYRange","max","getFirstLastVisiblePoint","first","last","points_1","doLinearAnimation","clipRectElement","childNodes","animated","effect","elementHeight","elementWidth","xCenter","yCenter","requireInvertedAxis","value"],"mappings":"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","sourcesContent":["/* eslint-disable no-trailing-spaces */\n/* eslint-disable @typescript-eslint/ban-types */\n/* eslint-disable @typescript-eslint/no-inferrable-types */\n/* eslint-disable jsdoc/require-returns */\n/* eslint-disable valid-jsdoc */\n/* eslint-disable jsdoc/require-param */\nimport { getAnimationFunction, pathAnimation, getElement } from '../../common/utils/helper';\nimport { Rect } from '@syncfusion/ej2-svg-base';\nimport { Animation, isNullOrUndefined } from '@syncfusion/ej2-base';\n/**\n * Base for line type series.\n */\nvar LineBase = /** @class */ (function () {\n    /** @private */\n    function LineBase(chartModule) {\n        this.chart = chartModule;\n    }\n    /**\n     * To improve the chart performance.\n     *\n     * @returns {void}\n     * @private\n     */\n    LineBase.prototype.enableComplexProperty = function (series) {\n        var tempPoints = [];\n        var tempPoints2 = [];\n        var xVisibleRange = series.xAxis.visibleRange;\n        var yVisibleRange = series.yAxis.visibleRange;\n        var seriesPoints = series.points;\n        var areaBounds = series.clipRect;\n        var xTolerance = Math.abs(xVisibleRange.delta / areaBounds.width);\n        var yTolerance = Math.abs(yVisibleRange.delta / areaBounds.height);\n        var prevXValue = (seriesPoints[0] && seriesPoints[0].x > xTolerance) ? 0 : xTolerance;\n        var prevYValue = (seriesPoints[0] && seriesPoints[0].y > yTolerance) ? 0 : yTolerance;\n        var xVal = 0;\n        var yVal = 0;\n        for (var _i = 0, seriesPoints_1 = seriesPoints; _i < seriesPoints_1.length; _i++) {\n            var currentPoint = seriesPoints_1[_i];\n            currentPoint.symbolLocations = [];\n            xVal = currentPoint.xValue ? currentPoint.xValue : xVisibleRange.min;\n            yVal = currentPoint.yValue ? currentPoint.yValue : yVisibleRange.min;\n            if (Math.abs(prevXValue - xVal) >= xTolerance || Math.abs(prevYValue - yVal) >= yTolerance) {\n                tempPoints.push(currentPoint);\n                prevXValue = xVal;\n                prevYValue = yVal;\n            }\n        }\n        var tempPoint;\n        for (var i = 0; i < tempPoints.length; i++) {\n            tempPoint = tempPoints[i];\n            if (isNullOrUndefined(tempPoint.x) || tempPoint.x === '' || (series.category === 'Indicator' && (isNaN(tempPoint.xValue) || isNaN(tempPoint.yValue)))) {\n                continue;\n            }\n            else {\n                tempPoints2.push(tempPoint);\n            }\n        }\n        return tempPoints2;\n    };\n    /**\n     * To generate the line path direction\n     *\n     * @param {Points} firstPoint firstPoint\n     * @param {Points} secondPoint secondPoint\n     * @param {Series} series series\n     * @param {boolean} isInverted isInverted\n     * @param {Function} getPointLocation getPointLocation\n     * @param {string} startPoint startPoint\n     */\n    LineBase.prototype.getLineDirection = function (firstPoint, secondPoint, series, isInverted, getPointLocation, startPoint) {\n        var direction = '';\n        if (firstPoint != null) {\n            var point1 = getPointLocation(firstPoint.xValue, firstPoint.yValue, series.xAxis, series.yAxis, isInverted, series);\n            var point2 = getPointLocation(secondPoint.xValue, secondPoint.yValue, series.xAxis, series.yAxis, isInverted, series);\n            direction = startPoint + ' ' + (point1.x) + ' ' + (point1.y) + ' ' +\n                'L' + ' ' + (point2.x) + ' ' + (point2.y) + ' ';\n        }\n        return direction;\n    };\n    /**\n     * To append the line path.\n     *\n     * @returns {void}\n     * @private\n     */\n    LineBase.prototype.appendLinePath = function (options, series, clipRect) {\n        var element = getElement(options.id);\n        var chart = series.chart;\n        var previousDirection = element ? element.getAttribute('d') : null;\n        var htmlObject = series.chart.renderer.drawPath(options, new Int32Array([series.clipRect.x, series.clipRect.y]));\n        if (htmlObject) {\n            htmlObject.setAttribute('clip-path', clipRect);\n        }\n        series.pathElement = htmlObject;\n        if (!series.chart.enableCanvas) {\n            series.seriesElement.appendChild(htmlObject);\n        }\n        series.isRectSeries = false;\n        pathAnimation(element, options.d, series.chart.redraw, previousDirection, chart.duration);\n    };\n    /**\n     * To render the marker for the series.\n     *\n     * @returns {void}\n     * @private\n     */\n    LineBase.prototype.renderMarker = function (series) {\n        if (series.marker && series.marker.visible) {\n            series.chart.markerRender.render(series);\n        }\n    };\n    /**\n     * To do the progressive animation.\n     *\n     * @returns {void}\n     * @private\n     */\n    LineBase.prototype.doProgressiveAnimation = function (series, option) {\n        var animation = new Animation({});\n        var path = series.pathElement;\n        var strokeDashArray = path.getAttribute('stroke-dasharray');\n        var pathLength = series.pathElement.getTotalLength();\n        var currentTime;\n        path.style.visibility = 'hidden';\n        animation.animate(path, {\n            duration: option.duration,\n            delay: option.delay,\n            progress: function (args) {\n                if (args.timeStamp >= args.delay) {\n                    path.style.visibility = 'visible';\n                    currentTime = Math.abs(Math.round(((args.timeStamp - args.delay) * pathLength) / args.duration));\n                    path.setAttribute('stroke-dasharray', currentTime + ',' + pathLength);\n                }\n            },\n            end: function () {\n                path.setAttribute('stroke-dasharray', strokeDashArray);\n                series.chart.trigger('animationComplete', { series: series.chart.isBlazor ? {} : series });\n            }\n        });\n    };\n    /**\n     * To store the symbol location and region\n     *\n     * @param {Points} point point\n     * @param {Series} series series\n     * @param {boolean} isInverted isInverted\n     * @param {Function} getLocation getLocation\n     */\n    LineBase.prototype.storePointLocation = function (point, series, isInverted, getLocation) {\n        var markerWidth = (series.marker && series.marker.width) ? series.marker.width : 0;\n        var markerHeight = (series.marker && series.marker.height) ? series.marker.height : 0;\n        point.symbolLocations.push(getLocation(point.xValue, point.yValue, series.xAxis, series.yAxis, isInverted, series));\n        point.regions.push(new Rect(point.symbolLocations[0].x - markerWidth, point.symbolLocations[0].y - markerHeight, 2 * markerWidth, 2 * markerHeight));\n    };\n    /**\n     * To find point with in the visible range\n     *\n     * @param {Points} point point\n     * @param {Axis} yAxis yAxis\n     * @private\n     */\n    LineBase.prototype.withinYRange = function (point, yAxis) {\n        return point.yValue >= yAxis.visibleRange.min && point.yValue <= yAxis.visibleRange.max;\n    };\n    /**\n     * To get first and last visible points\n     *\n     * @private\n     */\n    LineBase.prototype.getFirstLastVisiblePoint = function (points) {\n        var first = null;\n        var last = null;\n        for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {\n            var point = points_1[_i];\n            if (first === null && point.visible) {\n                first = last = point;\n            }\n            last = point.visible ? point : last;\n        }\n        return { first: first ? first : points[0], last: last ? last : points[points.length - 1] };\n    };\n    /**\n     * To do the linear animation.\n     *\n     * @returns {void}\n     * @private\n     */\n    LineBase.prototype.doLinearAnimation = function (series, animation) {\n        var clipRect = series.clipRectElement.childNodes[0].childNodes[0];\n        var duration = series.chart.animated ? series.chart.duration : animation.duration;\n        var effect = getAnimationFunction('Linear');\n        var elementHeight = +clipRect.getAttribute('height');\n        var elementWidth = +clipRect.getAttribute('width');\n        var xCenter = +clipRect.getAttribute('x');\n        var yCenter = series.chart.requireInvertedAxis ? +clipRect.getAttribute('height') + +clipRect.getAttribute('y') :\n            +clipRect.getAttribute('y');\n        var value;\n        clipRect.style.visibility = 'hidden';\n        new Animation({}).animate(clipRect, {\n            duration: duration,\n            delay: animation.delay,\n            progress: function (args) {\n                if (args.timeStamp >= args.delay) {\n                    clipRect.style.visibility = 'visible';\n                    if (series.chart.requireInvertedAxis) {\n                        value = effect(args.timeStamp - args.delay, 0, elementHeight, args.duration);\n                        clipRect.setAttribute('transform', 'translate(' + xCenter + ' ' + yCenter +\n                            ') scale(1,' + (value / elementHeight) + ') translate(' + (-xCenter) + ' ' + (-yCenter) + ')');\n                    }\n                    else {\n                        value = effect(args.timeStamp - args.delay, 0, elementWidth, args.duration);\n                        clipRect.setAttribute('transform', 'translate(' + xCenter + ' ' + yCenter +\n                            ') scale(' + (value / elementWidth) + ', 1) translate(' + (-xCenter) + ' ' + (-yCenter) + ')');\n                    }\n                }\n            },\n            end: function () {\n                clipRect.setAttribute('transform', 'translate(0,0)');\n                series.chart.trigger('animationComplete', { series: series.chart.isBlazor ? {} : series });\n            }\n        });\n    };\n    return LineBase;\n}());\nexport { LineBase };\n"]},"metadata":{},"sourceType":"module"}