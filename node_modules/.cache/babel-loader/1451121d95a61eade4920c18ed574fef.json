{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/* eslint-disable @typescript-eslint/no-inferrable-types */\n\n/* eslint-disable valid-jsdoc */\n\n/* eslint-disable jsdoc/require-param */\n\n/**\n * AccumulationChart DataLabel module file\n */\n\n\nimport { extend, createElement, getValue, isNullOrUndefined } from '@syncfusion/ej2-base';\nimport { Rect, PathOption, measureText, TextOption } from '@syncfusion/ej2-svg-base';\nimport { ChartLocation, degreeToLocation, isOverlap, stringToNumber, getAngle, appendChildElement } from '../../common/utils/helper';\nimport { textTrim, subtractThickness, Thickness, getElement } from '../../common/utils/helper';\nimport { removeElement, RectOption, textElement, showTooltip } from '../../common/utils/helper';\nimport { colorNameToHex, convertHexToColor, containsRect } from '../../common/utils/helper';\nimport { getSeriesFromIndex } from '../model/acc-base';\nimport { textRender } from '../../common/model/constants';\nimport { getFontStyle, createTemplate, measureElementRect, templateAnimate } from '../../common/utils/helper';\nimport { AccumulationBase } from './accumulation-base';\n/**\n * AccumulationDataLabel module used to render `dataLabel`.\n */\n\nvar AccumulationDataLabel =\n/** @class */\nfunction (_super) {\n  __extends(AccumulationDataLabel, _super);\n\n  function AccumulationDataLabel(accumulation) {\n    var _this = _super.call(this, accumulation) || this;\n\n    _this.rightSideRenderingPoints = [];\n    _this.leftSideRenderingPoints = [];\n    _this.id = accumulation.element.id + '_datalabel_Series_';\n\n    if (accumulation.title) {\n      var titleSize = measureText(accumulation.title, accumulation.titleStyle);\n      _this.titleRect = new Rect(accumulation.availableSize.width / 2 - titleSize.width / 2, accumulation.margin.top, titleSize.width, titleSize.height);\n    }\n\n    return _this;\n  }\n  /**\n   * Method to get datalabel text location.\n   *\n   * @private\n   */\n\n\n  AccumulationDataLabel.prototype.getDataLabelPosition = function (point, dataLabel, textSize, points) {\n    var radius = this.isCircular() ? !this.isVariousRadius() ? this.accumulation.pieSeriesModule.labelRadius : this.accumulation.pieSeriesModule.getLabelRadius(this.accumulation.visibleSeries[0], point) : this.getLabelDistance(point, dataLabel); //let radius: number = this.isCircular() ? this.labelRadius : this.getLabelDistance(point, dataLabel);\n\n    this.getLabelRegion(point, dataLabel.position, textSize, radius, this.marginValue);\n    point.labelAngle = point.midAngle;\n    point.labelPosition = dataLabel.position;\n\n    if (this.accumulation.enableSmartLabels) {\n      this.getSmartLabel(point, dataLabel, textSize, points);\n    }\n  };\n  /**\n   * Method to get datalabel bound.\n   */\n\n\n  AccumulationDataLabel.prototype.getLabelRegion = function (point, position, textSize, labelRadius, margin, endAngle) {\n    if (endAngle === void 0) {\n      endAngle = 0;\n    }\n\n    var labelAngle = endAngle || point.midAngle;\n    var space = 10;\n    var location = degreeToLocation(labelAngle, labelRadius, this.isCircular() ? this.center : this.getLabelLocation(point, position));\n    location.y = position === 'Inside' ? location.y - textSize.height / 2 : location.y;\n    location.x = position === 'Inside' ? location.x - textSize.width / 2 : location.x;\n    point.labelRegion = new Rect(location.x, location.y, textSize.width + margin * 2, textSize.height + margin * 2);\n\n    if (position === 'Outside') {\n      point.labelRegion.y -= point.labelRegion.height / 2;\n\n      if (labelAngle >= 90 && labelAngle <= 270) {\n        point.labelRegion.x -= point.labelRegion.width + space;\n      } else {\n        point.labelRegion.x += space;\n      }\n    }\n  };\n  /**\n   * Method to get datalabel smart position.\n   */\n\n\n  AccumulationDataLabel.prototype.getSmartLabel = function (point, dataLabel, textSize, points) {\n    var circular = this.isCircular();\n    var labelRadius = circular ? this.radius : this.getLabelDistance(point, dataLabel);\n    var connectorLength = circular ? dataLabel.connectorStyle.length || '4%' : '0px';\n    labelRadius += stringToNumber(connectorLength, labelRadius);\n    var previousPoint = this.findPreviousPoint(points, point.index, point.labelPosition);\n\n    if (dataLabel.position === 'Inside') {\n      // `4` is padding adding to height and width of label region.\n      point.labelRegion.height -= 4;\n      point.labelRegion.width -= 4;\n\n      if (previousPoint && previousPoint.labelRegion && (isOverlap(point.labelRegion, previousPoint.labelRegion) || this.isOverlapping(point, points)) || !circular && !containsRect(point.region, point.labelRegion)) {\n        point.labelPosition = 'Outside';\n\n        if (!circular) {\n          labelRadius = this.getLabelDistance(point, dataLabel);\n        }\n\n        this.getLabelRegion(point, point.labelPosition, textSize, labelRadius, this.marginValue);\n        previousPoint = this.findPreviousPoint(points, point.index, point.labelPosition);\n\n        if (previousPoint && (isOverlap(point.labelRegion, previousPoint.labelRegion) || this.isConnectorLineOverlapping(point, previousPoint))) {\n          this.setOuterSmartLabel(previousPoint, point, dataLabel.border.width, labelRadius, textSize, this.marginValue);\n        }\n      }\n    } else {\n      if (previousPoint && previousPoint.labelRegion && (isOverlap(point.labelRegion, previousPoint.labelRegion) || this.isOverlapping(point, points) || this.isConnectorLineOverlapping(point, previousPoint))) {\n        this.setOuterSmartLabel(previousPoint, point, dataLabel.border.width, labelRadius, textSize, this.marginValue);\n      }\n    }\n\n    if (this.isOverlapping(point, points) && (this.accumulation.type === 'Pyramid' || this.accumulation.type === 'Funnel')) {\n      var position = 'OutsideLeft';\n      var space = 10;\n      var labelAngle = point.midAngle || 0;\n      var labelRadius_1 = circular ? this.radius : this.getLabelDistance(point, dataLabel);\n      var location_1 = degreeToLocation(labelAngle, -labelRadius_1, this.isCircular() ? this.center : this.getLabelLocation(point, position));\n      point.labelRegion = new Rect(location_1.x, location_1.y, textSize.width + this.marginValue * 2, textSize.height + this.marginValue * 2);\n      point.labelRegion.y -= point.labelRegion.height / 2;\n      point.labelRegion.x = point.labelRegion.x - space - point.labelRegion.width;\n\n      if (previousPoint && previousPoint.labelRegion && (isOverlap(point.labelRegion, previousPoint.labelRegion) || this.isOverlapping(point, points) || this.isConnectorLineOverlapping(point, previousPoint))) {\n        this.setOuterSmartLabel(previousPoint, point, dataLabel.border.width, labelRadius_1, textSize, this.marginValue);\n      }\n    }\n  };\n  /**\n   * To find trimmed datalabel tooltip needed.\n   *\n   * @returns {void}\n   * @private\n   */\n\n\n  AccumulationDataLabel.prototype.move = function (e, x, y, isTouch) {\n    var _this = this;\n\n    if (e.target.textContent.indexOf('...') > -1) {\n      var targetId = e.target.id.split(this.id);\n\n      if (targetId.length === 2) {\n        var seriesIndex = parseInt(targetId[1].split('_text_')[0], 10);\n        var pointIndex = parseInt(targetId[1].split('_text_')[1], 10);\n\n        if (!isNaN(seriesIndex) && !isNaN(pointIndex)) {\n          if (isTouch) {\n            removeElement(this.accumulation.element.id + '_EJ2_Datalabel_Tooltip');\n          }\n\n          var point = getSeriesFromIndex(seriesIndex, this.accumulation.visibleSeries).points[pointIndex];\n          showTooltip(point.text || point.y.toString(), x, y, this.areaRect.width, this.accumulation.element.id + '_EJ2_Datalabel_Tooltip', getElement(this.accumulation.element.id + '_Secondary_Element'));\n        }\n      }\n    } else {\n      removeElement(this.accumulation.element.id + '_EJ2_Datalabel_Tooltip');\n    }\n\n    if (isTouch) {\n      clearTimeout(this.clearTooltip);\n      this.clearTooltip = +setTimeout(function () {\n        removeElement(_this.accumulation.element.id + '_EJ2_Datalabel_Tooltip');\n      }, 1000);\n    }\n  };\n  /**\n   * To find previous valid label point\n   *\n   * @returns {AccPoints} Find the previous value of accumulation point.\n   */\n\n\n  AccumulationDataLabel.prototype.findPreviousPoint = function (points, index, position) {\n    var point = points[0];\n\n    for (var i = index - 1; i >= 0; i--) {\n      point = points[i];\n\n      if (point.visible && point.labelVisible && point.labelRegion && point.labelPosition === position) {\n        return point;\n      }\n    }\n\n    return null;\n  };\n  /**\n   * To find current point datalabel is overlapping with other points\n   *\n   * @returns {boolean} It returns boolean value of overlapping.\n   */\n\n\n  AccumulationDataLabel.prototype.isOverlapping = function (currentPoint, points) {\n    for (var i = currentPoint.index - 1; i >= 0; i--) {\n      if (points[i].visible && points[i].labelVisible && points[i].labelRegion && currentPoint.labelRegion && currentPoint.labelVisible && isOverlap(currentPoint.labelRegion, points[i].labelRegion)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\n   * To get text trimmed while exceeds the accumulation chart area.\n   */\n\n\n  AccumulationDataLabel.prototype.textTrimming = function (point, rect, font, position) {\n    if (isOverlap(point.labelRegion, rect)) {\n      var size = point.labelRegion.width;\n\n      if (position === 'Right') {\n        size = rect.x - point.labelRegion.x;\n      } else if (position === 'Left') {\n        size = point.labelRegion.x - (rect.x + rect.width);\n\n        if (size < 0) {\n          size += point.labelRegion.width;\n          point.labelRegion.x = rect.x + rect.width;\n        }\n      } else if (position === 'InsideRight') {\n        size = rect.x + rect.width - point.labelRegion.x;\n      } else if (position === 'InsideLeft') {\n        size = point.labelRegion.x + point.labelRegion.width - rect.x;\n\n        if (size < point.labelRegion.width) {\n          point.labelRegion.x = rect.x;\n        }\n      } else {\n        this.setPointVisibileFalse(point);\n      }\n\n      if (point.labelVisible && point.labelRegion) {\n        if (size < point.labelRegion.width) {\n          point.label = textTrim(size - this.marginValue * 2, point.label, font);\n          point.labelRegion.width = size;\n        }\n\n        if (point.label.length === 3 && point.label.indexOf('...') > -1) {\n          this.setPointVisibileFalse(point);\n        }\n      }\n    }\n  };\n  /**\n   * To set point label visible and region to disable.\n   */\n\n\n  AccumulationDataLabel.prototype.setPointVisibileFalse = function (point) {\n    point.labelVisible = false;\n    point.labelRegion = null;\n  };\n  /**\n   * To set point label visible to enable.\n   */\n\n\n  AccumulationDataLabel.prototype.setPointVisibleTrue = function (point) {\n    point.labelVisible = true;\n  };\n  /**\n   * To set datalabel angle position for outside labels\n   */\n\n\n  AccumulationDataLabel.prototype.setOuterSmartLabel = function (previousPoint, point, border, labelRadius, textsize, margin) {\n    if (!this.isCircular()) {\n      this.setSmartLabelForSegments(point, previousPoint);\n    } else {\n      var labelAngle = this.getOverlappedAngle(previousPoint.labelRegion, point.labelRegion, point.midAngle, border * 2);\n      this.getLabelRegion(point, 'Outside', textsize, labelRadius, margin, labelAngle);\n\n      if (labelAngle > point.endAngle) {\n        labelAngle = point.midAngle; //this.setPointVisibileFalse(point);\n      }\n\n      point.labelAngle = labelAngle;\n\n      while (point.labelVisible && (isOverlap(previousPoint.labelRegion, point.labelRegion) || labelAngle <= previousPoint.labelAngle || this.isConnectorLineOverlapping(point, previousPoint))) {\n        if (labelAngle > point.endAngle) {\n          //this.setPointVisibileFalse(point);\n          break;\n        }\n\n        point.labelAngle = labelAngle;\n        this.getLabelRegion(point, 'Outside', textsize, labelRadius, margin, labelAngle);\n        labelAngle += 0.1;\n      }\n    }\n  };\n  /**\n   * Sets smart label positions for funnel and pyramid series\n   *\n   * @returns {void} setSmartLabelForSegments.\n   */\n\n\n  AccumulationDataLabel.prototype.setSmartLabelForSegments = function (point, prevPoint) {\n    var textRegion = point.labelRegion; //let overlapWidth: number = prevPoint.labelRegion.x + prevPoint.labelRegion.width - textRegion.x;\n\n    var overlapHeight = this.accumulation.type === 'Funnel' ? prevPoint.labelRegion.y - (textRegion.y + textRegion.height) : point.labelRegion.y - (prevPoint.labelRegion.y + prevPoint.labelRegion.height);\n\n    if (overlapHeight < 0) {\n      point.labelRegion.y += this.accumulation.type === 'Funnel' ? overlapHeight : -overlapHeight;\n    }\n  };\n  /**\n   * To find connector line overlapping.\n   *\n   * @returns {boolean} To find connector line overlapping or not.\n   */\n\n\n  AccumulationDataLabel.prototype.isConnectorLineOverlapping = function (point, previous) {\n    var position;\n\n    if (!this.isCircular() && point.labelRegion.x < point.region.x) {\n      position = 'outsideLeft';\n    }\n\n    var start = this.getLabelLocation(point, position);\n    var end = new ChartLocation(0, 0);\n    this.getEdgeOfLabel(point.labelRegion, point.labelAngle, end, 0, point);\n    var previousstart = this.getLabelLocation(previous);\n    var previousend = new ChartLocation(0, 0);\n    this.getEdgeOfLabel(previous.labelRegion, previous.labelAngle, previousend, 0, point);\n    return this.isLineRectangleIntersect(start, end, point.labelRegion) || this.isLineRectangleIntersect(start, end, previous.labelRegion) || this.isLineRectangleIntersect(previousstart, previousend, point.labelRegion);\n  };\n  /**\n   * To find two rectangle intersect\n   *\n   * @returns {boolean} To find line rectangle intersect value.\n   */\n\n\n  AccumulationDataLabel.prototype.isLineRectangleIntersect = function (line1, line2, rect) {\n    var rectPoints = [new ChartLocation(Math.round(rect.x), Math.round(rect.y)), new ChartLocation(Math.round(rect.x + rect.width), Math.round(rect.y)), new ChartLocation(Math.round(rect.x + rect.width), Math.round(rect.y + rect.height)), new ChartLocation(Math.round(rect.x), Math.round(rect.y + rect.height))];\n    line1.x = Math.round(line1.x);\n    line1.y = Math.round(line1.y);\n    line2.x = Math.round(line2.x);\n    line2.y = Math.round(line2.y);\n\n    for (var i = 0; i < rectPoints.length; i++) {\n      if (this.isLinesIntersect(line1, line2, rectPoints[i], rectPoints[(i + 1) % rectPoints.length])) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\n   * To find two line intersect\n   *\n   * @returns {boolean} To find line intersect or not.\n   */\n\n\n  AccumulationDataLabel.prototype.isLinesIntersect = function (point1, point2, point11, point12) {\n    var a1 = point2.y - point1.y;\n    var b1 = point1.x - point2.x;\n    var c1 = a1 * point1.x + b1 * point1.y;\n    var a2 = point12.y - point11.y;\n    var b2 = point11.x - point12.x;\n    var c2 = a2 * point11.x + b2 * point11.y;\n    var delta = a1 * b2 - a2 * b1;\n\n    if (delta !== 0) {\n      var x = (b2 * c1 - b1 * c2) / delta;\n      var y = (a1 * c2 - a2 * c1) / delta;\n      var lies = Math.min(point1.x, point2.x) <= x && x <= Math.max(point1.x, point2.x);\n      lies = lies && Math.min(point1.y, point2.y) <= y && y <= Math.max(point1.y, point2.y);\n      lies = lies && Math.min(point11.x, point12.x) <= x && x <= Math.max(point11.x, point12.x);\n      lies = lies && Math.min(point11.y, point12.y) <= y && y <= Math.max(point11.y, point12.y);\n      return lies;\n    }\n\n    return false;\n  };\n  /**\n   * To get two rectangle overlapping angles.\n   *\n   * @returns {number} Get overlapped angle.\n   */\n\n\n  AccumulationDataLabel.prototype.getOverlappedAngle = function (first, second, angle, padding) {\n    var x = first.x;\n\n    if (angle >= 90 && angle <= 270) {\n      second.y = first.y - (padding + second.height / 2);\n      x = first.x + first.width;\n    } else {\n      second.y = first.y + first.height + padding;\n    }\n\n    return getAngle(this.center, new ChartLocation(x, second.y));\n  };\n  /**\n   * To get connector line path\n   *\n   * @returns {string} Get connector line path.\n   */\n\n\n  AccumulationDataLabel.prototype.getConnectorPath = function (label, point, dataLabel, end) {\n    if (end === void 0) {\n      end = 0;\n    }\n\n    var connector = dataLabel.connectorStyle;\n    var labelRadius = this.isCircular() ? !this.isVariousRadius() ? this.labelRadius : this.accumulation.pieSeriesModule.getLabelRadius(this.accumulation.visibleSeries[0], point) : this.getLabelDistance(point, dataLabel); //let labelRadius: number = this.isCircular() ? this.labelRadius : this.getLabelDistance(point, dataLabel);\n\n    var start = this.getConnectorStartPoint(point, connector);\n    var labelAngle = this.accumulation.enableSmartLabels ? point.midAngle : end || point.midAngle;\n    var middle = new ChartLocation(0, 0);\n    var endPoint = this.getEdgeOfLabel(label, labelAngle, middle, connector.width, point);\n\n    if (connector.type === 'Curve') {\n      if (this.isCircular()) {\n        var r = labelRadius - (this.isVariousRadius() ? stringToNumber(point.sliceRadius, this.accumulation.pieSeriesModule.seriesRadius) : this.radius); //let r: number = labelRadius - this.radius;\n\n        if (point.isLabelUpdated) {\n          middle = this.getPerpendicularDistance(start, point);\n        } else {\n          middle = degreeToLocation(labelAngle, labelRadius - r / 2, this.center);\n\n          if (point.labelPosition === 'Outside' && dataLabel.position === 'Inside') {\n            middle = degreeToLocation(labelAngle, labelRadius - r * 1.25, this.center);\n          }\n        }\n\n        return 'M ' + start.x + ' ' + start.y + ' Q ' + middle.x + ' ' + middle.y + ' ' + endPoint.x + ' ' + endPoint.y;\n      } else {\n        return this.getPolyLinePath(start, endPoint);\n      }\n    } else {\n      return 'M ' + start.x + ' ' + start.y + ' L ' + middle.x + ' ' + middle.y + ' L ' + endPoint.x + ' ' + endPoint.y;\n    }\n  };\n  /**\n   * Finds the curved path for funnel/pyramid data label connectors\n   *\n   * @returns {string} Get poly line path.\n   */\n\n\n  AccumulationDataLabel.prototype.getPolyLinePath = function (start, end) {\n    var controlPoints = [start, end];\n\n    if (start.y === end.y) {\n      return 'M ' + start.x + ' ' + start.y + ' L ' + end.x + ' ' + end.y;\n    }\n\n    var path = 'M';\n\n    for (var i = 0; i <= 16; i++) {\n      var t = i / 16;\n      var points = this.getBezierPoint(t, controlPoints, 0, 2);\n      path += points.x + ',' + points.y;\n\n      if (i !== 16) {\n        path += ' L';\n      }\n    }\n\n    return path;\n  };\n  /**\n   * Finds the bezier point for funnel/pyramid data label connectors\n   *\n   * @returns {ChartLocation} Get bazier point.\n   */\n\n\n  AccumulationDataLabel.prototype.getBezierPoint = function (t, controlPoints, index, count) {\n    if (count === 1) {\n      return controlPoints[index];\n    }\n\n    var p0 = this.getBezierPoint(t, controlPoints, index, count - 1);\n    var p1 = this.getBezierPoint(t, controlPoints, index + 1, count - 1);\n    var x = p0.x ? p0.x : p0.x;\n    var y = p0.y ? p0.y : p0.y;\n    var x1 = p1.x ? p1.x : p1.x;\n    var y1 = p1.y ? p1.y : p1.y;\n    var x2 = (1 - t) * x + t * x1;\n    var y2 = (1 - t) * y + t * y1;\n\n    if (p0.x) {\n      return {\n        x: x2,\n        y: y2\n      };\n    } else {\n      return {\n        x: x2,\n        y: y2\n      };\n    }\n  };\n  /**\n   * To get label edges based on the center and label rect position.\n   *\n   * @returns {ChartLocation} Get label edge value.\n   */\n\n\n  AccumulationDataLabel.prototype.getEdgeOfLabel = function (labelshape, angle, middle, border, point) {\n    if (border === void 0) {\n      border = 1;\n    }\n\n    var edge = new ChartLocation(labelshape.x, labelshape.y);\n\n    if (angle >= 90 && angle <= 270) {\n      edge.x += labelshape.width + border / 2;\n      edge.y += labelshape.height / 2;\n      middle.x = edge.x + 10;\n      middle.y = edge.y;\n    } else if (point && point.region && point.region.x > point.labelRegion.x) {\n      edge.x += border * 2 + labelshape.width;\n      edge.y += labelshape.height / 2;\n      middle.x = edge.x + 10;\n      middle.y = edge.y;\n    } else {\n      edge.x -= border / 2;\n      edge.y += labelshape.height / 2;\n      middle.x = edge.x - 10;\n      middle.y = edge.y;\n    }\n\n    return edge;\n  };\n  /**\n   * Finds the distance between the label position and the edge/center of the funnel/pyramid\n   *\n   * @returns {number} Get label distance.\n   */\n\n\n  AccumulationDataLabel.prototype.getLabelDistance = function (point, dataLabel) {\n    if (point.labelPosition && dataLabel.position !== point.labelPosition || dataLabel.connectorStyle.length) {\n      var length_1 = stringToNumber(dataLabel.connectorStyle.length || '70px', this.accumulation.initialClipRect.width);\n\n      if (length_1 < this.accumulation.initialClipRect.width) {\n        return length_1;\n      }\n    }\n\n    var position = point.labelPosition || dataLabel.position;\n    var series = this.accumulation.visibleSeries[0];\n    var extraSpace = (this.accumulation.initialClipRect.width - series.triangleSize.width) / 2;\n    var labelLocation;\n\n    switch (position) {\n      case 'Inside':\n        return 0;\n\n      case 'Outside':\n        labelLocation = point.symbolLocation.x + point.labelOffset.x;\n        return this.accumulation.initialClipRect.width - labelLocation - extraSpace;\n    }\n  };\n  /**\n   * Finds the label position / beginning of the connector(ouside funnel labels)\n   *\n   * @returns {ChartLocation} Get label location.\n   */\n\n\n  AccumulationDataLabel.prototype.getLabelLocation = function (point, position) {\n    if (position === void 0) {\n      position = 'Outside';\n    }\n\n    if (this.accumulation.type !== 'Pie') {\n      position = position === 'OutsideLeft' ? 'OutsideLeft' : point.labelPosition || position;\n      var location_2 = {\n        x: point.symbolLocation.x,\n        y: point.symbolLocation.y - point.labelOffset.y\n      };\n\n      switch (position) {\n        case 'Inside':\n          location_2.y = point.region.y + point.region.height / 2;\n          break;\n\n        case 'Outside':\n          location_2.x += point.labelOffset.x;\n          break;\n\n        case 'OutsideLeft':\n          location_2.x -= point.labelOffset.x;\n      }\n\n      return location_2;\n    } else {\n      //return degreeToLocation(point.midAngle, this.radius, this.center);\n      return degreeToLocation(point.midAngle, this.isVariousRadius() ? stringToNumber(point.sliceRadius, this.accumulation.pieSeriesModule.seriesRadius) : this.radius, this.center);\n    }\n  };\n  /**\n   * Finds the beginning of connector line\n   *\n   * @returns {ChartLocation} Staring point of connector line.\n   */\n\n\n  AccumulationDataLabel.prototype.getConnectorStartPoint = function (point, connector) {\n    // return this.isCircular() ? degreeToLocation(point.midAngle, this.radius - connector.width, this.center) :\n    //     this.getLabelLocation(point);\n    var position;\n\n    if (!this.isCircular() && point.region.x > point.labelRegion.x) {\n      position = 'OutsideLeft';\n    }\n\n    return this.isCircular() ? degreeToLocation(point.midAngle, (this.isVariousRadius() ? stringToNumber(point.sliceRadius, this.accumulation.pieSeriesModule.seriesRadius) : this.radius) - connector.width, this.center) : this.getLabelLocation(point, position);\n  };\n  /**\n   * To find area rect based on margin, available size.\n   *\n   * @private\n   */\n\n\n  AccumulationDataLabel.prototype.findAreaRect = function () {\n    this.areaRect = new Rect(0, 0, this.accumulation.availableSize.width, this.accumulation.availableSize.height);\n    var margin = this.accumulation.margin;\n    subtractThickness(this.areaRect, new Thickness(margin.left, margin.right, margin.top, margin.bottom));\n  };\n  /**\n   * To render the data labels from series points.\n   */\n\n\n  AccumulationDataLabel.prototype.renderDataLabel = function (point, dataLabel, parent, points, series, templateElement, redraw) {\n    var id = this.accumulation.element.id + '_datalabel_Series_' + series + '_';\n    var datalabelGroup = this.accumulation.renderer.createGroup({\n      id: id + 'g_' + point.index\n    });\n    point.label = point.originalText || point.y.toString();\n    var border = {\n      width: dataLabel.border.width,\n      color: dataLabel.border.color\n    };\n    var argsFont = extend({}, getValue('properties', dataLabel.font), null, true);\n    var argsData = {\n      cancel: false,\n      name: textRender,\n      series: this.accumulation.visibleSeries[0],\n      point: point,\n      text: point.label,\n      border: border,\n      color: dataLabel.fill,\n      template: dataLabel.template,\n      font: argsFont\n    };\n    this.accumulation.trigger(textRender, argsData);\n    point.argsData = argsData;\n    var isTemplate = argsData.template !== null;\n    point.labelVisible = !argsData.cancel;\n    point.text = point.label = argsData.text;\n\n    if (Number(point.label)) {\n      point.label = this.accumulation.intl.formatNumber(+point.label, {\n        useGrouping: this.accumulation.useGroupingSeparator\n      });\n    }\n\n    this.marginValue = argsData.border.width ? 5 + argsData.border.width : 1;\n    var childElement = createElement('div', {\n      id: this.accumulation.element.id + '_Series_' + 0 + '_DataLabel_' + point.index,\n      styles: 'position: absolute;background-color:' + argsData.color + ';' + getFontStyle(dataLabel.font) + ';border:' + argsData.border.width + 'px solid ' + argsData.border.color + ';'\n    });\n    this.calculateLabelSize(isTemplate, childElement, point, points, argsData, datalabelGroup, id, dataLabel, redraw);\n  };\n  /**\n   * To calculate label size\n   */\n\n\n  AccumulationDataLabel.prototype.calculateLabelSize = function (isTemplate, childElement, point, points, argsData, datalabelGroup, id, dataLabel, redraw, clientRect, isReactCallback) {\n    var textSize = isTemplate ? isReactCallback ? {\n      width: clientRect.width,\n      height: clientRect.height\n    } : this.getTemplateSize(childElement, point, argsData, redraw, isTemplate, points, datalabelGroup, id, dataLabel) : measureText(point.label, dataLabel.font);\n    textSize.height += 4; // 4 for calculation with padding for smart label shape\n\n    textSize.width += 4;\n    point.textSize = textSize;\n    point.templateElement = childElement;\n    this.getDataLabelPosition(point, dataLabel, textSize, points);\n\n    if (point.labelRegion) {\n      this.correctLabelRegion(point.labelRegion, point.textSize);\n    }\n  };\n  /**\n   * @private\n   */\n\n\n  AccumulationDataLabel.prototype.drawDataLabels = function (series, dataLabel, parent, templateElement, redraw) {\n    var angle;\n    var degree;\n    var modifiedPoints = series.leftSidePoints.concat(series.rightSidePoints);\n    modifiedPoints.sort(function (a, b) {\n      return a.index - b.index;\n    });\n\n    if (series.type === 'Pie' && this.accumulation.enableSmartLabels) {\n      this.extendedLabelsCalculation();\n    }\n\n    for (var _i = 0, modifiedPoints_1 = modifiedPoints; _i < modifiedPoints_1.length; _i++) {\n      var point = modifiedPoints_1[_i];\n\n      if (!isNullOrUndefined(point.argsData) && !isNullOrUndefined(point.y)) {\n        this.finalizeDatalabels(point, modifiedPoints, dataLabel);\n        var id = this.accumulation.element.id + '_datalabel_Series_' + 0 + '_';\n        var datalabelGroup = this.accumulation.renderer.createGroup({\n          id: id + 'g_' + point.index\n        });\n        var dataLabelElement = void 0;\n        var location_3 = void 0;\n        var element = void 0;\n\n        if (point.visible && point.labelVisible) {\n          angle = degree = dataLabel.angle;\n\n          if (point.argsData.template) {\n            this.setTemplateStyle(point.templateElement, point, templateElement, dataLabel.font.color, point.color, redraw);\n          } else {\n            location_3 = new ChartLocation(point.labelRegion.x + this.marginValue, point.labelRegion.y + point.textSize.height * 3 / 4 + this.marginValue);\n            element = getElement(id + 'shape_' + point.index);\n            var startLocation = element ? new ChartLocation(+element.getAttribute('x'), +element.getAttribute('y')) : null;\n            dataLabelElement = this.accumulation.renderer.drawRectangle(new RectOption(id + 'shape_' + point.index, point.argsData.color, point.argsData.border, 1, point.labelRegion, dataLabel.rx, dataLabel.ry));\n            appendChildElement(false, datalabelGroup, dataLabelElement, redraw, true, 'x', 'y', startLocation, null, false, false, null, this.accumulation.duration);\n            var textWidth = point.textSize.width;\n            var textHeight = point.textSize.height;\n            var rotate = void 0;\n\n            if (angle !== 0 && dataLabel.enableRotation) {\n              if (point.labelPosition === 'Outside') {\n                degree = 0;\n              } else {\n                if (point.midAngle >= 90 && point.midAngle <= 270) {\n                  degree = point.midAngle + 180;\n                } else {\n                  degree = point.midAngle;\n                }\n              }\n\n              rotate = 'rotate(' + degree + ',' + (location_3.x + textWidth / 2) + ',' + (location_3.y - textHeight / 4) + ')';\n            } else {\n              if (angle) {\n                degree = angle > 360 ? angle - 360 : angle < -360 ? angle + 360 : angle;\n              } else {\n                degree = 0;\n              }\n\n              rotate = 'rotate(' + degree + ',' + (location_3.x + textWidth / 2) + ',' + location_3.y + ')';\n            }\n\n            point.transform = rotate;\n            textElement(this.accumulation.renderer, new TextOption(id + 'text_' + point.index, location_3.x, location_3.y, this.accumulation.enableRtl ? 'end' : 'start', point.label, rotate, 'auto', degree), point.argsData.font, point.argsData.font.color || this.getSaturatedColor(point, point.argsData.color), datalabelGroup, false, redraw, true, false, this.accumulation.duration);\n            element = null;\n          }\n\n          if (this.accumulation.accumulationLegendModule && this.accumulation.legendSettings.visible && (dataLabel.position === 'Outside' || this.accumulation.enableSmartLabels)) {\n            this.accumulation.visibleSeries[0].findMaxBounds(this.accumulation.visibleSeries[0].labelBound, point.labelRegion);\n          }\n\n          if (point.labelPosition === 'Outside') {\n            var element_1 = getElement(id + 'connector_' + point.index);\n            var previousDirection = element_1 ? element_1.getAttribute('d') : '';\n            var pathElement = this.accumulation.renderer.drawPath(new PathOption(id + 'connector_' + point.index, 'transparent', dataLabel.connectorStyle.width, dataLabel.connectorStyle.color || point.color, 1, dataLabel.connectorStyle.dashArray, this.getConnectorPath(extend({}, point.labelRegion, null, true), point, dataLabel, point.labelAngle)));\n            appendChildElement(false, datalabelGroup, pathElement, redraw, true, null, null, null, previousDirection, false, false, null, this.accumulation.duration);\n          }\n\n          appendChildElement(false, parent, datalabelGroup, redraw);\n        }\n      }\n    }\n  };\n  /**\n   * In this method datalabels region checked with legebdBounds and areaBounds.\n   * Trimming of datalabel and point's visibility again changed here.\n   *\n   * @param {AccPoints} point current point in which trimming and visibility to be checked\n   * @param {AccPoints[]} points finalized points\n   * @param {AccumulationDataLabelSettingsModel} dataLabel datalabel model\n   */\n\n\n  AccumulationDataLabel.prototype.finalizeDatalabels = function (point, points, dataLabel) {\n    if (this.isOverlapping(point, points) || this.titleRect && point.labelRegion && isOverlap(point.labelRegion, this.titleRect)) {\n      if (this.isCircular() && point.labelPosition === 'Outside') {\n        this.setPointVisibileFalse(point);\n      }\n    }\n\n    if (this.accumulation.accumulationLegendModule && this.accumulation.legendSettings.visible && point.labelVisible && point.labelRegion) {\n      var rect = this.accumulation.accumulationLegendModule.legendBounds;\n\n      if (this.accumulation.visibleSeries[0].type != \"Pie\" && this.accumulation.legendSettings.position == 'Left' && dataLabel.position === 'Outside') {\n        point.labelRegion.x = point.labelRegion.x + rect.width;\n      }\n\n      var padding = this.accumulation.legendSettings.border.width / 2;\n      this.textTrimming(point, new Rect(rect.x - padding, rect.y - padding, rect.width + 2 * padding, rect.height + 2 * padding), dataLabel.font, this.accumulation.accumulationLegendModule.position);\n    }\n\n    if (point.labelVisible && point.labelRegion) {\n      var position = this.isCircular() ? point.labelRegion.x >= this.center.x ? 'InsideRight' : 'InsideLeft' : point.labelRegion.x >= point.region.x ? 'InsideRight' : 'InsideLeft';\n      this.textTrimming(point, this.areaRect, dataLabel.font, position);\n    }\n\n    if (point.labelVisible && point.labelRegion && (point.labelRegion.y + point.labelRegion.height > this.areaRect.y + this.areaRect.height || point.labelRegion.y < this.areaRect.y || point.labelRegion.x < this.areaRect.x || point.labelRegion.x + point.labelRegion.width > this.areaRect.x + this.areaRect.width)) {\n      this.setPointVisibileFalse(point);\n    }\n  };\n  /**\n   * To find the template element size\n   *\n   * @param {HTMLElement} element To get a template element.\n   * @param {AccPoints} point Template of accumulation points.\n   * @param {IAccTextRenderEventArgs} argsData Arguments of accumulation points.\n   * @param {boolean} redraw redraw value.\n   * @returns {Size} Size of a template.\n   */\n\n\n  AccumulationDataLabel.prototype.getTemplateSize = function (element, point, argsData, redraw, isTemplate, points, datalabelGroup, id, dataLabel) {\n    element = createTemplate(element, point.index, argsData.template, this.accumulation, point, this.accumulation.visibleSeries[0], this.accumulation.element.id + '_DataLabel', 0, argsData, isTemplate, points, datalabelGroup, id, dataLabel, redraw);\n    var clientRect = measureElementRect(element, redraw);\n    return {\n      width: clientRect.width,\n      height: clientRect.height\n    };\n  };\n  /**\n   * To set the template element style\n   *\n   * @param {HTMLElement} childElement Set a child element of template.\n   * @param {AccPoints} point Template point.\n   * @param {parent} parent Parent element of template.\n   * @param {labelColor} labelColor Template label color.\n   * @param {string} fill Fill color of template.\n   */\n\n\n  AccumulationDataLabel.prototype.setTemplateStyle = function (childElement, point, parent, labelColor, fill, redraw) {\n    childElement.style.left = point.labelRegion.x + 'px';\n    childElement.style.top = point.labelRegion.y + 'px';\n    childElement.style.color = labelColor || this.getSaturatedColor(point, fill);\n\n    if (this.accumulation.isBlazor) {\n      var position = this.isCircular() ? point.labelRegion.x >= this.center.x ? 'InsideRight' : 'InsideLeft' : point.labelRegion.x >= point.region.x ? 'InsideRight' : 'InsideLeft';\n\n      if (position === 'InsideRight') {\n        childElement.style.transform = 'translate(0%, -50%)';\n      } else {\n        childElement.style.transform = 'translate(-100%, -50%)';\n      }\n    }\n\n    if (childElement.childElementCount) {\n      appendChildElement(false, parent, childElement, redraw, true, 'left', 'top');\n      this.doTemplateAnimation(this.accumulation, childElement);\n    }\n  };\n  /**\n   * To find saturated color for datalabel\n   *\n   * @returns {string} Get a saturated color.\n   */\n\n\n  AccumulationDataLabel.prototype.getSaturatedColor = function (point, color) {\n    var saturatedColor;\n\n    if (this.marginValue >= 1) {\n      saturatedColor = color === 'transparent' ? this.getLabelBackground(point) : color;\n    } else {\n      saturatedColor = this.getLabelBackground(point);\n    }\n\n    saturatedColor = saturatedColor === 'transparent' ? window.getComputedStyle(document.body, null).backgroundColor : saturatedColor;\n    var rgbValue = convertHexToColor(colorNameToHex(saturatedColor));\n    var contrast = Math.round((rgbValue.r * 299 + rgbValue.g * 587 + rgbValue.b * 114) / 1000);\n    return contrast >= 128 ? 'black' : 'white';\n  };\n  /**\n   * Animates the data label template.\n   *\n   * @returns {void}\n   * @private\n   */\n\n\n  AccumulationDataLabel.prototype.doTemplateAnimation = function (accumulation, element) {\n    var series = accumulation.visibleSeries[0];\n    var delay = series.animation.delay + series.animation.duration;\n\n    if (series.animation.enable && accumulation.animateSeries) {\n      element.style.visibility = 'hidden';\n      templateAnimate(element, delay, 200, 'ZoomIn');\n    }\n  };\n  /**\n   * To find background color for the datalabel\n   *\n   * @returns {string} AccPoints\n   */\n\n\n  AccumulationDataLabel.prototype.getLabelBackground = function (point) {\n    return point.labelPosition === 'Outside' ? this.accumulation.background || this.accumulation.themeStyle.background : !point.y ? this.accumulation.theme.indexOf('dark') ? 'white' : 'black' : point.color;\n  };\n  /**\n   * To correct the padding between datalabel regions.\n   */\n\n\n  AccumulationDataLabel.prototype.correctLabelRegion = function (labelRegion, textSize, padding) {\n    if (padding === void 0) {\n      padding = 4;\n    }\n\n    labelRegion.height -= padding;\n    labelRegion.width -= padding;\n    labelRegion.x += padding / 2;\n    labelRegion.y += padding / 2;\n    textSize.height -= padding;\n    textSize.width -= padding;\n  };\n  /**\n   * To get the dataLabel module name\n   *\n   * @returns {string} module name\n   */\n\n\n  AccumulationDataLabel.prototype.getModuleName = function () {\n    return 'AccumulationDataLabel';\n  };\n  /**\n   * To destroy the data label.\n   *\n   * @returns {void}\n   * @private\n   */\n\n\n  AccumulationDataLabel.prototype.destroy = function () {\n    /**\n     * Destroy method performed here\n     */\n  }; //calculation for placing labels smartly\n\n\n  AccumulationDataLabel.prototype.extendedLabelsCalculation = function () {\n    var _this = this;\n\n    var series = this.accumulation.series[0];\n    series.rightSidePoints.forEach(function (point, index, halfSidePoints) {\n      point.initialLabelRegion = point.labelRegion;\n      point.isLabelUpdated = 0;\n\n      _this.skipPoints(point, halfSidePoints, index);\n    });\n    series.leftSidePoints.forEach(function (point, index, halfSidePoints) {\n      point.initialLabelRegion = point.labelRegion;\n      point.isLabelUpdated = 0;\n\n      _this.skipPoints(point, halfSidePoints, index);\n    });\n    this.arrangeLeftSidePoints(series);\n    this.isIncreaseAngle = false;\n    this.arrangeRightSidePoints(series);\n  };\n  /**\n   * Rightside points alignments calculation\n   *\n   * @param {AccumulationSeries} series To get a proper series.\n   */\n\n\n  AccumulationDataLabel.prototype.arrangeRightSidePoints = function (series) {\n    var startFresh;\n    var angleChanged;\n    var rightSideRenderPoints = series.rightSidePoints.filter(function (point) {\n      return point.labelVisible && point.labelPosition === 'Outside';\n    });\n    this.rightSideRenderingPoints = rightSideRenderPoints;\n    var checkAngle;\n    var currentPoint;\n    var lastPoint = rightSideRenderPoints[rightSideRenderPoints.length - 1];\n    var nextPoint;\n\n    if (lastPoint) {\n      if (lastPoint.labelAngle > 90 && lastPoint.labelAngle < 270) {\n        this.isIncreaseAngle = true;\n        this.changeLabelAngle(lastPoint, 89);\n      }\n    }\n    /**\n     * Right side points arranged from last point.\n     * A point checked with successive points for overlapping.\n     * If that is overlapped, its label angle is decreased and placing in optimal position\n     * If one point's angle is decreased, its previous points in the half side points also decreased until it reaced optimum position.\n     * When decreasing angle falls beyond 270, label angle increased.\n     * If one point's angle is increased, its successive points in that half point also increased until it reaced optimum position.\n     */\n\n\n    for (var i = rightSideRenderPoints.length - 1; i >= 0; i--) {\n      currentPoint = rightSideRenderPoints[i];\n      nextPoint = rightSideRenderPoints[i + 1]; // A point checked for overlapping, label visibility\n\n      if (this.isOverlapWithNext(currentPoint, rightSideRenderPoints, i) && currentPoint.labelVisible || !(currentPoint.labelAngle <= 90 || currentPoint.labelAngle >= 270)) {\n        checkAngle = lastPoint.labelAngle + 10;\n        angleChanged = true; //If last's point change angle in beyond the limit, stop the increasing angle and do decrease the angle.\n\n        if (startFresh) {\n          this.isIncreaseAngle = false;\n        } else if (checkAngle > 90 && checkAngle < 270 && nextPoint.isLabelUpdated) {\n          this.isIncreaseAngle = true;\n        }\n\n        if (!this.isIncreaseAngle) {\n          for (var k = i + 1; k < rightSideRenderPoints.length; k++) {\n            this.increaseAngle(rightSideRenderPoints[k - 1], rightSideRenderPoints[k], series, true);\n          }\n        } else {\n          for (var k = i + 1; k > 0; k--) {\n            this.decreaseAngle(rightSideRenderPoints[k], rightSideRenderPoints[k - 1], series, true);\n          }\n        }\n      } else {\n        //If a point did not overlapped with previous points, increase the angle always for right side points.\n        if (angleChanged && nextPoint && !nextPoint.isLabelUpdated) {\n          startFresh = true;\n        }\n      }\n    }\n  };\n  /**\n   * Leftside points alignments calculation\n   *\n   * @param {AccumulationSeries} series To get a proper series.\n   */\n\n\n  AccumulationDataLabel.prototype.arrangeLeftSidePoints = function (series) {\n    var _this = this;\n\n    var leftSideRenderPoints = series.leftSidePoints.filter(function (point) {\n      return point.labelVisible && point.labelPosition === 'Outside';\n    });\n    this.leftSideRenderingPoints = leftSideRenderPoints;\n    var previousPoint;\n    var currentPoint;\n    var angleChanged;\n    var startFresh;\n    /**\n     * Left side points arranged from first point.\n     * A point checked with previous points for overlapping.\n     * If that is overlapped, its label angle is decreased and placing in optimal position\n     * If one point's angle is decreased, its previous points in the half side points also decreased until it reaced optimum position.\n     * When decreasing angle falls beyond 90, label angle increased.\n     * If one point's angle is increased, its successive points in that half point also increased until it reaced optimum position.\n     */\n\n    for (var i = 0; i < leftSideRenderPoints.length; i++) {\n      currentPoint = leftSideRenderPoints[i];\n      previousPoint = leftSideRenderPoints[i - 1]; // A point checked\n\n      if (this.isOverlapWithPrevious(currentPoint, leftSideRenderPoints, i) && currentPoint.labelVisible || !(currentPoint.labelAngle < 270)) {\n        angleChanged = true;\n\n        if (startFresh) {\n          this.isIncreaseAngle = false;\n        }\n\n        if (!this.isIncreaseAngle) {\n          for (var k = i; k > 0; k--) {\n            this.decreaseAngle(leftSideRenderPoints[k], leftSideRenderPoints[k - 1], series, false);\n            leftSideRenderPoints.filter(function (point, index) {\n              if (point.isLabelUpdated && leftSideRenderPoints[index].labelAngle - 10 < 100) {\n                _this.isIncreaseAngle = true;\n              }\n            });\n          }\n        } else {\n          for (var k = i; k < leftSideRenderPoints.length; k++) {\n            this.increaseAngle(leftSideRenderPoints[k - 1], leftSideRenderPoints[k], series, false);\n          }\n        }\n      } else {\n        if (angleChanged && previousPoint && previousPoint.isLabelUpdated) {\n          startFresh = true;\n        }\n      }\n    }\n  };\n\n  AccumulationDataLabel.prototype.decreaseAngle = function (currentPoint, previousPoint, series, isRightSide) {\n    if (isNullOrUndefined(currentPoint) || isNullOrUndefined(previousPoint)) {\n      return null;\n    }\n\n    var count = 1;\n\n    if (isRightSide) {\n      while (isOverlap(currentPoint.labelRegion, previousPoint.labelRegion) || !this.isVariousRadius() && !(previousPoint.labelRegion.height + previousPoint.labelRegion.y < currentPoint.labelRegion.y)) {\n        var newAngle = previousPoint.midAngle - count;\n\n        if (newAngle < 0) {\n          newAngle = 360 + newAngle;\n        }\n\n        if (newAngle <= 270 && newAngle >= 90) {\n          newAngle = 270;\n          this.isIncreaseAngle = true;\n          break;\n        }\n\n        this.changeLabelAngle(previousPoint, newAngle);\n        count++;\n      }\n    } else {\n      if (currentPoint.labelAngle > 270) {\n        this.changeLabelAngle(currentPoint, 270);\n        previousPoint.labelAngle = 270;\n      }\n\n      while (isOverlap(currentPoint.labelRegion, previousPoint.labelRegion) || !this.isVariousRadius() && currentPoint.labelRegion.y + currentPoint.labelRegion.height > previousPoint.labelRegion.y) {\n        var newAngle = previousPoint.midAngle - count;\n\n        if (!(newAngle <= 270 && newAngle >= 90)) {\n          newAngle = 90;\n          this.isIncreaseAngle = true;\n          break;\n        }\n\n        this.changeLabelAngle(previousPoint, newAngle);\n\n        if (isOverlap(currentPoint.labelRegion, previousPoint.labelRegion) && !series.leftSidePoints.indexOf(previousPoint) && newAngle - 1 < 90 && newAngle - 1 > 270) {\n          this.changeLabelAngle(currentPoint, currentPoint.labelAngle + 1);\n          this.arrangeLeftSidePoints(series);\n          break;\n        }\n\n        count++;\n      }\n    }\n  };\n\n  AccumulationDataLabel.prototype.increaseAngle = function (currentPoint, nextPoint, series, isRightSide) {\n    if (isNullOrUndefined(currentPoint) || isNullOrUndefined(nextPoint)) {\n      return null;\n    }\n\n    var count = 1;\n\n    if (isRightSide) {\n      while (isOverlap(currentPoint.labelRegion, nextPoint.labelRegion) || !this.isVariousRadius() && !(currentPoint.labelRegion.y + currentPoint.labelRegion.height < nextPoint.labelRegion.y)) {\n        var newAngle = nextPoint.midAngle + count;\n\n        if (newAngle < 270 && newAngle > 90) {\n          newAngle = 90;\n          this.isIncreaseAngle = true;\n          break;\n        }\n\n        this.changeLabelAngle(nextPoint, newAngle);\n\n        if (isOverlap(currentPoint.labelRegion, nextPoint.labelRegion) && newAngle + 1 > 90 && newAngle + 1 < 270 && this.rightSideRenderingPoints.indexOf(nextPoint) === this.rightSideRenderingPoints.length - 1) {\n          this.changeLabelAngle(currentPoint, currentPoint.labelAngle - 1);\n          nextPoint.labelRegion = nextPoint.initialLabelRegion;\n          this.arrangeRightSidePoints(series);\n          break;\n        }\n\n        count++;\n      }\n    } else {\n      while (isOverlap(currentPoint.labelRegion, nextPoint.labelRegion) || !this.isVariousRadius() && currentPoint.labelRegion.y < nextPoint.labelRegion.y + nextPoint.labelRegion.height) {\n        var newAngle = nextPoint.midAngle + count;\n\n        if (!(newAngle < 270 && newAngle > 90)) {\n          newAngle = 270;\n          this.isIncreaseAngle = false;\n          break;\n        }\n\n        this.changeLabelAngle(nextPoint, newAngle);\n        count++;\n      }\n    }\n  };\n\n  AccumulationDataLabel.prototype.changeLabelAngle = function (currentPoint, newAngle) {\n    var dataLabel = this.accumulation.series[0].dataLabel;\n    var variableR;\n\n    if (this.isVariousRadius()) {\n      variableR = this.accumulation.pieSeriesModule.getLabelRadius(this.accumulation.visibleSeries[0], currentPoint);\n    } //padding 10px is added to label radius for increasing the angle and avoid congestion.\n\n\n    var labelRadius = currentPoint.labelPosition === 'Outside' && this.accumulation.enableSmartLabels && dataLabel.position === 'Inside' ? this.radius + stringToNumber(dataLabel.connectorStyle.length || '4%', this.accumulation.pieSeriesModule.size / 2) : !this.isVariousRadius() ? this.accumulation.pieSeriesModule.labelRadius + 10 : variableR;\n    var radius = !this.isVariousRadius() ? labelRadius : variableR;\n    this.getLabelRegion(currentPoint, 'Outside', currentPoint.textSize, radius, this.marginValue, newAngle);\n    currentPoint.isLabelUpdated = 1;\n    currentPoint.labelAngle = newAngle;\n  };\n\n  AccumulationDataLabel.prototype.isOverlapWithPrevious = function (currentPoint, points, currentPointIndex) {\n    for (var i = 0; i < currentPointIndex; i++) {\n      if (i !== points.indexOf(currentPoint) && points[i].visible && points[i].labelVisible && points[i].labelRegion && currentPoint.labelRegion && currentPoint.labelVisible && isOverlap(currentPoint.labelRegion, points[i].labelRegion)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  AccumulationDataLabel.prototype.isOverlapWithNext = function (point, points, pointIndex) {\n    for (var i = pointIndex; i < points.length; i++) {\n      if (i !== points.indexOf(point) && points[i].visible && points[i].labelVisible && points[i].labelRegion && point.labelRegion && point.labelVisible && isOverlap(point.labelRegion, points[i].labelRegion)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  AccumulationDataLabel.prototype.skipPoints = function (currentPoint, halfsidePoints, pointIndex) {\n    if (pointIndex > 0 && (currentPoint.midAngle < 285 && currentPoint.midAngle > 255 || currentPoint.midAngle < 105 && currentPoint.midAngle > 75)) {\n      var previousPoint = halfsidePoints[pointIndex - 1];\n      var angleDiff = currentPoint.endAngle % 360 - currentPoint.startAngle % 360;\n      var prevAngleDiff = previousPoint.endAngle % 360 - previousPoint.startAngle % 360;\n\n      if (prevAngleDiff <= angleDiff && angleDiff < 5 && previousPoint.labelVisible) {\n        this.setPointVisibleTrue(currentPoint);\n      }\n    } else if (pointIndex > 1 && (currentPoint.midAngle < 300 && currentPoint.midAngle > 240 || currentPoint.midAngle < 120 && currentPoint.midAngle > 60)) {\n      var prevPoint = halfsidePoints[pointIndex - 1];\n      var secondPrevPoint = halfsidePoints[pointIndex - 2];\n      var angleDiff = currentPoint.endAngle % 360 - currentPoint.startAngle % 360;\n      var prevAngleDiff = prevPoint.endAngle % 360 - prevPoint.startAngle % 360;\n      var thirdAngleDiff = secondPrevPoint.endAngle % 360 - secondPrevPoint.startAngle % 360;\n\n      if (angleDiff < 3 && prevAngleDiff < 3 && thirdAngleDiff < 3 && prevPoint.labelVisible && currentPoint.labelVisible) {\n        this.setPointVisibleTrue(currentPoint);\n      }\n    }\n  };\n\n  AccumulationDataLabel.prototype.getPerpendicularDistance = function (startPoint, point) {\n    var increasedLocation;\n    var add = 10;\n    var height = add + 10 * Math.sin(point.midAngle * Math.PI / 360);\n\n    if (point.midAngle > 270 && point.midAngle < 360) {\n      increasedLocation = new ChartLocation(startPoint.x + height * Math.cos((360 - point.midAngle) * Math.PI / 180), startPoint.y - height * Math.sin((360 - point.midAngle) * Math.PI / 180));\n    } else if (point.midAngle > 0 && point.midAngle < 90) {\n      increasedLocation = new ChartLocation(startPoint.x + height * Math.cos(point.midAngle * Math.PI / 180), startPoint.y + height * Math.sin(point.midAngle * Math.PI / 180));\n    } else if (point.midAngle > 0 && point.midAngle < 90) {\n      increasedLocation = new ChartLocation(startPoint.x - height * Math.cos((point.midAngle - 90) * Math.PI / 180), startPoint.y + height * Math.sin((point.midAngle - 90) * Math.PI / 180));\n    } else {\n      increasedLocation = new ChartLocation(startPoint.x - height * Math.cos((point.midAngle - 180) * Math.PI / 180), startPoint.y - height * Math.sin((point.midAngle - 180) * Math.PI / 180));\n    }\n\n    return increasedLocation;\n  };\n\n  return AccumulationDataLabel;\n}(AccumulationBase);\n\nexport { AccumulationDataLabel };","map":{"version":3,"sources":["C:/Users/khang/OneDrive/Tài liệu/JS/PersonalDashdoard/dashboard/node_modules/@syncfusion/ej2-react-charts/node_modules/@syncfusion/ej2-charts/src/accumulation-chart/renderer/dataLabel.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","extend","createElement","getValue","isNullOrUndefined","Rect","PathOption","measureText","TextOption","ChartLocation","degreeToLocation","isOverlap","stringToNumber","getAngle","appendChildElement","textTrim","subtractThickness","Thickness","getElement","removeElement","RectOption","textElement","showTooltip","colorNameToHex","convertHexToColor","containsRect","getSeriesFromIndex","textRender","getFontStyle","createTemplate","measureElementRect","templateAnimate","AccumulationBase","AccumulationDataLabel","_super","accumulation","_this","call","rightSideRenderingPoints","leftSideRenderingPoints","id","element","title","titleSize","titleStyle","titleRect","availableSize","width","margin","top","height","getDataLabelPosition","point","dataLabel","textSize","points","radius","isCircular","isVariousRadius","pieSeriesModule","labelRadius","getLabelRadius","visibleSeries","getLabelDistance","getLabelRegion","position","marginValue","labelAngle","midAngle","labelPosition","enableSmartLabels","getSmartLabel","endAngle","space","location","center","getLabelLocation","y","x","labelRegion","circular","connectorLength","connectorStyle","length","previousPoint","findPreviousPoint","index","isOverlapping","region","isConnectorLineOverlapping","setOuterSmartLabel","border","type","labelRadius_1","location_1","move","e","isTouch","target","textContent","indexOf","targetId","split","seriesIndex","parseInt","pointIndex","isNaN","text","toString","areaRect","clearTimeout","clearTooltip","setTimeout","i","visible","labelVisible","currentPoint","textTrimming","rect","font","size","setPointVisibileFalse","label","setPointVisibleTrue","textsize","setSmartLabelForSegments","getOverlappedAngle","prevPoint","textRegion","overlapHeight","previous","start","end","getEdgeOfLabel","previousstart","previousend","isLineRectangleIntersect","line1","line2","rectPoints","Math","round","isLinesIntersect","point1","point2","point11","point12","a1","b1","c1","a2","b2","c2","delta","lies","min","max","first","second","angle","padding","getConnectorPath","connector","getConnectorStartPoint","middle","endPoint","r","sliceRadius","seriesRadius","isLabelUpdated","getPerpendicularDistance","getPolyLinePath","controlPoints","path","t","getBezierPoint","count","p0","p1","x1","y1","x2","y2","labelshape","edge","length_1","initialClipRect","series","extraSpace","triangleSize","labelLocation","symbolLocation","labelOffset","location_2","findAreaRect","left","right","bottom","renderDataLabel","parent","templateElement","redraw","datalabelGroup","renderer","createGroup","originalText","color","argsFont","argsData","cancel","name","fill","template","trigger","isTemplate","Number","intl","formatNumber","useGrouping","useGroupingSeparator","childElement","styles","calculateLabelSize","clientRect","isReactCallback","getTemplateSize","correctLabelRegion","drawDataLabels","degree","modifiedPoints","leftSidePoints","concat","rightSidePoints","sort","a","extendedLabelsCalculation","_i","modifiedPoints_1","finalizeDatalabels","dataLabelElement","location_3","setTemplateStyle","startLocation","getAttribute","drawRectangle","rx","ry","duration","textWidth","textHeight","rotate","enableRotation","transform","enableRtl","getSaturatedColor","accumulationLegendModule","legendSettings","findMaxBounds","labelBound","element_1","previousDirection","pathElement","drawPath","dashArray","legendBounds","labelColor","style","isBlazor","childElementCount","doTemplateAnimation","saturatedColor","getLabelBackground","window","getComputedStyle","document","body","backgroundColor","rgbValue","contrast","g","delay","animation","enable","animateSeries","visibility","background","themeStyle","theme","getModuleName","destroy","forEach","halfSidePoints","initialLabelRegion","skipPoints","arrangeLeftSidePoints","isIncreaseAngle","arrangeRightSidePoints","startFresh","angleChanged","rightSideRenderPoints","filter","checkAngle","lastPoint","nextPoint","changeLabelAngle","isOverlapWithNext","k","increaseAngle","decreaseAngle","leftSideRenderPoints","isOverlapWithPrevious","isRightSide","newAngle","variableR","currentPointIndex","halfsidePoints","angleDiff","startAngle","prevAngleDiff","secondPrevPoint","thirdAngleDiff","startPoint","increasedLocation","add","sin","PI","cos"],"mappings":"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","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/* eslint-disable @typescript-eslint/no-inferrable-types */\n/* eslint-disable valid-jsdoc */\n/* eslint-disable jsdoc/require-param */\n/**\n * AccumulationChart DataLabel module file\n */\nimport { extend, createElement, getValue, isNullOrUndefined } from '@syncfusion/ej2-base';\nimport { Rect, PathOption, measureText, TextOption } from '@syncfusion/ej2-svg-base';\nimport { ChartLocation, degreeToLocation, isOverlap, stringToNumber, getAngle, appendChildElement } from '../../common/utils/helper';\nimport { textTrim, subtractThickness, Thickness, getElement } from '../../common/utils/helper';\nimport { removeElement, RectOption, textElement, showTooltip } from '../../common/utils/helper';\nimport { colorNameToHex, convertHexToColor, containsRect } from '../../common/utils/helper';\nimport { getSeriesFromIndex } from '../model/acc-base';\nimport { textRender } from '../../common/model/constants';\nimport { getFontStyle, createTemplate, measureElementRect, templateAnimate } from '../../common/utils/helper';\nimport { AccumulationBase } from './accumulation-base';\n/**\n * AccumulationDataLabel module used to render `dataLabel`.\n */\nvar AccumulationDataLabel = /** @class */ (function (_super) {\n    __extends(AccumulationDataLabel, _super);\n    function AccumulationDataLabel(accumulation) {\n        var _this = _super.call(this, accumulation) || this;\n        _this.rightSideRenderingPoints = [];\n        _this.leftSideRenderingPoints = [];\n        _this.id = accumulation.element.id + '_datalabel_Series_';\n        if (accumulation.title) {\n            var titleSize = measureText(accumulation.title, accumulation.titleStyle);\n            _this.titleRect = new Rect(accumulation.availableSize.width / 2 - titleSize.width / 2, accumulation.margin.top, titleSize.width, titleSize.height);\n        }\n        return _this;\n    }\n    /**\n     * Method to get datalabel text location.\n     *\n     * @private\n     */\n    AccumulationDataLabel.prototype.getDataLabelPosition = function (point, dataLabel, textSize, points) {\n        var radius = this.isCircular() ? (!this.isVariousRadius() ? this.accumulation.pieSeriesModule.labelRadius :\n            this.accumulation.pieSeriesModule.getLabelRadius(this.accumulation.visibleSeries[0], point)) :\n            this.getLabelDistance(point, dataLabel);\n        //let radius: number = this.isCircular() ? this.labelRadius : this.getLabelDistance(point, dataLabel);\n        this.getLabelRegion(point, dataLabel.position, textSize, radius, this.marginValue);\n        point.labelAngle = point.midAngle;\n        point.labelPosition = dataLabel.position;\n        if (this.accumulation.enableSmartLabels) {\n            this.getSmartLabel(point, dataLabel, textSize, points);\n        }\n    };\n    /**\n     * Method to get datalabel bound.\n     */\n    AccumulationDataLabel.prototype.getLabelRegion = function (point, position, textSize, labelRadius, margin, endAngle) {\n        if (endAngle === void 0) { endAngle = 0; }\n        var labelAngle = endAngle || point.midAngle;\n        var space = 10;\n        var location = degreeToLocation(labelAngle, labelRadius, this.isCircular() ? this.center :\n            this.getLabelLocation(point, position));\n        location.y = (position === 'Inside') ? (location.y - textSize.height / 2) : location.y;\n        location.x = (position === 'Inside') ? (location.x - textSize.width / 2) : location.x;\n        point.labelRegion = new Rect(location.x, location.y, textSize.width + (margin * 2), textSize.height + (margin * 2));\n        if (position === 'Outside') {\n            point.labelRegion.y -= point.labelRegion.height / 2;\n            if (labelAngle >= 90 && labelAngle <= 270) {\n                point.labelRegion.x -= (point.labelRegion.width + space);\n            }\n            else {\n                point.labelRegion.x += space;\n            }\n        }\n    };\n    /**\n     * Method to get datalabel smart position.\n     */\n    AccumulationDataLabel.prototype.getSmartLabel = function (point, dataLabel, textSize, points) {\n        var circular = this.isCircular();\n        var labelRadius = circular ? this.radius : this.getLabelDistance(point, dataLabel);\n        var connectorLength = circular ? (dataLabel.connectorStyle.length || '4%') :\n            '0px';\n        labelRadius += stringToNumber(connectorLength, labelRadius);\n        var previousPoint = this.findPreviousPoint(points, point.index, point.labelPosition);\n        if (dataLabel.position === 'Inside') {\n            // `4` is padding adding to height and width of label region.\n            point.labelRegion.height -= 4;\n            point.labelRegion.width -= 4;\n            if (previousPoint && previousPoint.labelRegion && (isOverlap(point.labelRegion, previousPoint.labelRegion)\n                || this.isOverlapping(point, points)) || !circular && !containsRect(point.region, point.labelRegion)) {\n                point.labelPosition = 'Outside';\n                if (!circular) {\n                    labelRadius = this.getLabelDistance(point, dataLabel);\n                }\n                this.getLabelRegion(point, point.labelPosition, textSize, labelRadius, this.marginValue);\n                previousPoint = this.findPreviousPoint(points, point.index, point.labelPosition);\n                if (previousPoint && (isOverlap(point.labelRegion, previousPoint.labelRegion) ||\n                    this.isConnectorLineOverlapping(point, previousPoint))) {\n                    this.setOuterSmartLabel(previousPoint, point, dataLabel.border.width, labelRadius, textSize, this.marginValue);\n                }\n            }\n        }\n        else {\n            if (previousPoint && previousPoint.labelRegion && (isOverlap(point.labelRegion, previousPoint.labelRegion)\n                || this.isOverlapping(point, points) || this.isConnectorLineOverlapping(point, previousPoint))) {\n                this.setOuterSmartLabel(previousPoint, point, dataLabel.border.width, labelRadius, textSize, this.marginValue);\n            }\n        }\n        if (this.isOverlapping(point, points) && (this.accumulation.type === 'Pyramid' || this.accumulation.type === 'Funnel')) {\n            var position = 'OutsideLeft';\n            var space = 10;\n            var labelAngle = point.midAngle || 0;\n            var labelRadius_1 = circular ? this.radius : this.getLabelDistance(point, dataLabel);\n            var location_1 = degreeToLocation(labelAngle, -labelRadius_1, this.isCircular() ? this.center :\n                this.getLabelLocation(point, position));\n            point.labelRegion = new Rect(location_1.x, location_1.y, textSize.width + (this.marginValue * 2), textSize.height + (this.marginValue * 2));\n            point.labelRegion.y -= point.labelRegion.height / 2;\n            point.labelRegion.x = point.labelRegion.x - space - point.labelRegion.width;\n            if (previousPoint && previousPoint.labelRegion && (isOverlap(point.labelRegion, previousPoint.labelRegion)\n                || this.isOverlapping(point, points) || this.isConnectorLineOverlapping(point, previousPoint))) {\n                this.setOuterSmartLabel(previousPoint, point, dataLabel.border.width, labelRadius_1, textSize, this.marginValue);\n            }\n        }\n    };\n    /**\n     * To find trimmed datalabel tooltip needed.\n     *\n     * @returns {void}\n     * @private\n     */\n    AccumulationDataLabel.prototype.move = function (e, x, y, isTouch) {\n        var _this = this;\n        if (e.target.textContent.indexOf('...') > -1) {\n            var targetId = e.target.id.split(this.id);\n            if (targetId.length === 2) {\n                var seriesIndex = parseInt(targetId[1].split('_text_')[0], 10);\n                var pointIndex = parseInt(targetId[1].split('_text_')[1], 10);\n                if (!isNaN(seriesIndex) && !isNaN(pointIndex)) {\n                    if (isTouch) {\n                        removeElement(this.accumulation.element.id + '_EJ2_Datalabel_Tooltip');\n                    }\n                    var point = getSeriesFromIndex(seriesIndex, (this.accumulation).visibleSeries).points[pointIndex];\n                    showTooltip(point.text || point.y.toString(), x, y, this.areaRect.width, this.accumulation.element.id + '_EJ2_Datalabel_Tooltip', getElement(this.accumulation.element.id + '_Secondary_Element'));\n                }\n            }\n        }\n        else {\n            removeElement(this.accumulation.element.id + '_EJ2_Datalabel_Tooltip');\n        }\n        if (isTouch) {\n            clearTimeout(this.clearTooltip);\n            this.clearTooltip = +setTimeout(function () { removeElement(_this.accumulation.element.id + '_EJ2_Datalabel_Tooltip'); }, 1000);\n        }\n    };\n    /**\n     * To find previous valid label point\n     *\n     * @returns {AccPoints} Find the previous value of accumulation point.\n     */\n    AccumulationDataLabel.prototype.findPreviousPoint = function (points, index, position) {\n        var point = points[0];\n        for (var i = index - 1; i >= 0; i--) {\n            point = points[i];\n            if (point.visible && point.labelVisible && point.labelRegion && point.labelPosition === position) {\n                return point;\n            }\n        }\n        return null;\n    };\n    /**\n     * To find current point datalabel is overlapping with other points\n     *\n     * @returns {boolean} It returns boolean value of overlapping.\n     */\n    AccumulationDataLabel.prototype.isOverlapping = function (currentPoint, points) {\n        for (var i = currentPoint.index - 1; i >= 0; i--) {\n            if (points[i].visible && points[i].labelVisible && points[i].labelRegion && currentPoint.labelRegion &&\n                currentPoint.labelVisible && isOverlap(currentPoint.labelRegion, points[i].labelRegion)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * To get text trimmed while exceeds the accumulation chart area.\n     */\n    AccumulationDataLabel.prototype.textTrimming = function (point, rect, font, position) {\n        if (isOverlap(point.labelRegion, rect)) {\n            var size = point.labelRegion.width;\n            if (position === 'Right') {\n                size = rect.x - point.labelRegion.x;\n            }\n            else if (position === 'Left') {\n                size = point.labelRegion.x - (rect.x + rect.width);\n                if (size < 0) {\n                    size += point.labelRegion.width;\n                    point.labelRegion.x = rect.x + rect.width;\n                }\n            }\n            else if (position === 'InsideRight') {\n                size = (rect.x + rect.width) - point.labelRegion.x;\n            }\n            else if (position === 'InsideLeft') {\n                size = (point.labelRegion.x + point.labelRegion.width) - rect.x;\n                if (size < point.labelRegion.width) {\n                    point.labelRegion.x = rect.x;\n                }\n            }\n            else {\n                this.setPointVisibileFalse(point);\n            }\n            if (point.labelVisible && point.labelRegion) {\n                if (size < point.labelRegion.width) {\n                    point.label = textTrim(size - (this.marginValue * 2), point.label, font);\n                    point.labelRegion.width = size;\n                }\n                if (point.label.length === 3 && point.label.indexOf('...') > -1) {\n                    this.setPointVisibileFalse(point);\n                }\n            }\n        }\n    };\n    /**\n     * To set point label visible and region to disable.\n     */\n    AccumulationDataLabel.prototype.setPointVisibileFalse = function (point) {\n        point.labelVisible = false;\n        point.labelRegion = null;\n    };\n    /**\n     * To set point label visible to enable.\n     */\n    AccumulationDataLabel.prototype.setPointVisibleTrue = function (point) {\n        point.labelVisible = true;\n    };\n    /**\n     * To set datalabel angle position for outside labels\n     */\n    AccumulationDataLabel.prototype.setOuterSmartLabel = function (previousPoint, point, border, labelRadius, textsize, margin) {\n        if (!this.isCircular()) {\n            this.setSmartLabelForSegments(point, previousPoint);\n        }\n        else {\n            var labelAngle = this.getOverlappedAngle(previousPoint.labelRegion, point.labelRegion, point.midAngle, border * 2);\n            this.getLabelRegion(point, 'Outside', textsize, labelRadius, margin, labelAngle);\n            if (labelAngle > point.endAngle) {\n                labelAngle = point.midAngle;\n                //this.setPointVisibileFalse(point);\n            }\n            point.labelAngle = labelAngle;\n            while (point.labelVisible && (isOverlap(previousPoint.labelRegion, point.labelRegion) || labelAngle <= previousPoint.labelAngle\n                || this.isConnectorLineOverlapping(point, previousPoint))) {\n                if (labelAngle > point.endAngle) {\n                    //this.setPointVisibileFalse(point);\n                    break;\n                }\n                point.labelAngle = labelAngle;\n                this.getLabelRegion(point, 'Outside', textsize, labelRadius, margin, labelAngle);\n                labelAngle += 0.1;\n            }\n        }\n    };\n    /**\n     * Sets smart label positions for funnel and pyramid series\n     *\n     * @returns {void} setSmartLabelForSegments.\n     */\n    AccumulationDataLabel.prototype.setSmartLabelForSegments = function (point, prevPoint) {\n        var textRegion = point.labelRegion;\n        //let overlapWidth: number = prevPoint.labelRegion.x + prevPoint.labelRegion.width - textRegion.x;\n        var overlapHeight = this.accumulation.type === 'Funnel' ?\n            prevPoint.labelRegion.y - (textRegion.y + textRegion.height) :\n            point.labelRegion.y - (prevPoint.labelRegion.y + prevPoint.labelRegion.height);\n        if (overlapHeight < 0) {\n            point.labelRegion.y += this.accumulation.type === 'Funnel' ? overlapHeight : -overlapHeight;\n        }\n    };\n    /**\n     * To find connector line overlapping.\n     *\n     * @returns {boolean} To find connector line overlapping or not.\n     */\n    AccumulationDataLabel.prototype.isConnectorLineOverlapping = function (point, previous) {\n        var position;\n        if (!this.isCircular() && point.labelRegion.x < point.region.x) {\n            position = 'outsideLeft';\n        }\n        var start = this.getLabelLocation(point, position);\n        var end = new ChartLocation(0, 0);\n        this.getEdgeOfLabel(point.labelRegion, point.labelAngle, end, 0, point);\n        var previousstart = this.getLabelLocation(previous);\n        var previousend = new ChartLocation(0, 0);\n        this.getEdgeOfLabel(previous.labelRegion, previous.labelAngle, previousend, 0, point);\n        return this.isLineRectangleIntersect(start, end, point.labelRegion) ||\n            this.isLineRectangleIntersect(start, end, previous.labelRegion) ||\n            this.isLineRectangleIntersect(previousstart, previousend, point.labelRegion);\n    };\n    /**\n     * To find two rectangle intersect\n     *\n     * @returns {boolean} To find line rectangle intersect value.\n     */\n    AccumulationDataLabel.prototype.isLineRectangleIntersect = function (line1, line2, rect) {\n        var rectPoints = [\n            new ChartLocation(Math.round(rect.x), Math.round(rect.y)),\n            new ChartLocation(Math.round((rect.x + rect.width)), Math.round(rect.y)),\n            new ChartLocation(Math.round((rect.x + rect.width)), Math.round((rect.y + rect.height))),\n            new ChartLocation(Math.round(rect.x), Math.round((rect.y + rect.height)))\n        ];\n        line1.x = Math.round(line1.x);\n        line1.y = Math.round(line1.y);\n        line2.x = Math.round(line2.x);\n        line2.y = Math.round(line2.y);\n        for (var i = 0; i < rectPoints.length; i++) {\n            if (this.isLinesIntersect(line1, line2, rectPoints[i], rectPoints[(i + 1) % rectPoints.length])) {\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * To find two line intersect\n     *\n     * @returns {boolean} To find line intersect or not.\n     */\n    AccumulationDataLabel.prototype.isLinesIntersect = function (point1, point2, point11, point12) {\n        var a1 = point2.y - point1.y;\n        var b1 = point1.x - point2.x;\n        var c1 = a1 * point1.x + b1 * point1.y;\n        var a2 = point12.y - point11.y;\n        var b2 = point11.x - point12.x;\n        var c2 = a2 * point11.x + b2 * point11.y;\n        var delta = a1 * b2 - a2 * b1;\n        if (delta !== 0) {\n            var x = (b2 * c1 - b1 * c2) / delta;\n            var y = (a1 * c2 - a2 * c1) / delta;\n            var lies = Math.min(point1.x, point2.x) <= x && x <= Math.max(point1.x, point2.x);\n            lies = lies && Math.min(point1.y, point2.y) <= y && y <= Math.max(point1.y, point2.y);\n            lies = lies && Math.min(point11.x, point12.x) <= x && x <= Math.max(point11.x, point12.x);\n            lies = lies && Math.min(point11.y, point12.y) <= y && y <= Math.max(point11.y, point12.y);\n            return lies;\n        }\n        return false;\n    };\n    /**\n     * To get two rectangle overlapping angles.\n     *\n     * @returns {number} Get overlapped angle.\n     */\n    AccumulationDataLabel.prototype.getOverlappedAngle = function (first, second, angle, padding) {\n        var x = first.x;\n        if (angle >= 90 && angle <= 270) {\n            second.y = first.y - (padding + second.height / 2);\n            x = first.x + first.width;\n        }\n        else {\n            second.y = first.y + first.height + padding;\n        }\n        return getAngle(this.center, new ChartLocation(x, second.y));\n    };\n    /**\n     * To get connector line path\n     *\n     * @returns {string} Get connector line path.\n     */\n    AccumulationDataLabel.prototype.getConnectorPath = function (label, point, dataLabel, end) {\n        if (end === void 0) { end = 0; }\n        var connector = dataLabel.connectorStyle;\n        var labelRadius = this.isCircular() ? (!this.isVariousRadius() ? this.labelRadius :\n            this.accumulation.pieSeriesModule.getLabelRadius(this.accumulation.visibleSeries[0], point)) :\n            this.getLabelDistance(point, dataLabel);\n        //let labelRadius: number = this.isCircular() ? this.labelRadius : this.getLabelDistance(point, dataLabel);\n        var start = this.getConnectorStartPoint(point, connector);\n        var labelAngle = this.accumulation.enableSmartLabels ? point.midAngle : end || point.midAngle;\n        var middle = new ChartLocation(0, 0);\n        var endPoint = this.getEdgeOfLabel(label, labelAngle, middle, connector.width, point);\n        if (connector.type === 'Curve') {\n            if (this.isCircular()) {\n                var r = labelRadius - (this.isVariousRadius() ? stringToNumber(point.sliceRadius, this.accumulation.pieSeriesModule.seriesRadius) :\n                    this.radius);\n                //let r: number = labelRadius - this.radius;\n                if (point.isLabelUpdated) {\n                    middle = this.getPerpendicularDistance(start, point);\n                }\n                else {\n                    middle = degreeToLocation(labelAngle, labelRadius - (r / 2), this.center);\n                    if (point.labelPosition === 'Outside' && dataLabel.position === 'Inside') {\n                        middle = degreeToLocation(labelAngle, labelRadius - r * 1.25, this.center);\n                    }\n                }\n                return 'M ' + start.x + ' ' + start.y + ' Q ' + middle.x + ' ' + middle.y + ' ' + endPoint.x + ' ' + endPoint.y;\n            }\n            else {\n                return this.getPolyLinePath(start, endPoint);\n            }\n        }\n        else {\n            return 'M ' + start.x + ' ' + start.y + ' L ' + middle.x + ' ' + middle.y + ' L ' + endPoint.x + ' ' + endPoint.y;\n        }\n    };\n    /**\n     * Finds the curved path for funnel/pyramid data label connectors\n     *\n     * @returns {string} Get poly line path.\n     */\n    AccumulationDataLabel.prototype.getPolyLinePath = function (start, end) {\n        var controlPoints = [start, end];\n        if (start.y === end.y) {\n            return 'M ' + start.x + ' ' + start.y + ' L ' + end.x + ' ' + end.y;\n        }\n        var path = 'M';\n        for (var i = 0; i <= 16; i++) {\n            var t = i / 16;\n            var points = this.getBezierPoint(t, controlPoints, 0, 2);\n            path += points.x + ',' + points.y;\n            if (i !== 16) {\n                path += ' L';\n            }\n        }\n        return path;\n    };\n    /**\n     * Finds the bezier point for funnel/pyramid data label connectors\n     *\n     * @returns {ChartLocation} Get bazier point.\n     */\n    AccumulationDataLabel.prototype.getBezierPoint = function (t, controlPoints, index, count) {\n        if (count === 1) {\n            return controlPoints[index];\n        }\n        var p0 = this.getBezierPoint(t, controlPoints, index, count - 1);\n        var p1 = this.getBezierPoint(t, controlPoints, index + 1, count - 1);\n        var x = (p0.x) ? p0.x : p0.x;\n        var y = (p0.y) ? p0.y : p0.y;\n        var x1 = (p1.x) ? p1.x : p1.x;\n        var y1 = (p1.y) ? p1.y : p1.y;\n        var x2 = (1 - t) * x + t * x1;\n        var y2 = (1 - t) * y + t * y1;\n        if (p0.x) {\n            return { x: x2, y: y2 };\n        }\n        else {\n            return { x: x2, y: y2 };\n        }\n    };\n    /**\n     * To get label edges based on the center and label rect position.\n     *\n     * @returns {ChartLocation} Get label edge value.\n     */\n    AccumulationDataLabel.prototype.getEdgeOfLabel = function (labelshape, angle, middle, border, point) {\n        if (border === void 0) { border = 1; }\n        var edge = new ChartLocation(labelshape.x, labelshape.y);\n        if (angle >= 90 && angle <= 270) {\n            edge.x += labelshape.width + border / 2;\n            edge.y += labelshape.height / 2;\n            middle.x = edge.x + 10;\n            middle.y = edge.y;\n        }\n        else if (point && point.region && point.region.x > point.labelRegion.x) {\n            edge.x += border * 2 + labelshape.width;\n            edge.y += labelshape.height / 2;\n            middle.x = edge.x + 10;\n            middle.y = edge.y;\n        }\n        else {\n            edge.x -= border / 2;\n            edge.y += labelshape.height / 2;\n            middle.x = edge.x - 10;\n            middle.y = edge.y;\n        }\n        return edge;\n    };\n    /**\n     * Finds the distance between the label position and the edge/center of the funnel/pyramid\n     *\n     * @returns {number} Get label distance.\n     */\n    AccumulationDataLabel.prototype.getLabelDistance = function (point, dataLabel) {\n        if (point.labelPosition && dataLabel.position !== point.labelPosition || dataLabel.connectorStyle.length) {\n            var length_1 = stringToNumber(dataLabel.connectorStyle.length || '70px', this.accumulation.initialClipRect.width);\n            if (length_1 < this.accumulation.initialClipRect.width) {\n                return length_1;\n            }\n        }\n        var position = point.labelPosition || dataLabel.position;\n        var series = this.accumulation.visibleSeries[0];\n        var extraSpace = (this.accumulation.initialClipRect.width - series.triangleSize.width) / 2;\n        var labelLocation;\n        switch (position) {\n            case 'Inside':\n                return 0;\n            case 'Outside':\n                labelLocation = point.symbolLocation.x + point.labelOffset.x;\n                return this.accumulation.initialClipRect.width - labelLocation - extraSpace;\n        }\n    };\n    /**\n     * Finds the label position / beginning of the connector(ouside funnel labels)\n     *\n     * @returns {ChartLocation} Get label location.\n     */\n    AccumulationDataLabel.prototype.getLabelLocation = function (point, position) {\n        if (position === void 0) { position = 'Outside'; }\n        if (this.accumulation.type !== 'Pie') {\n            position = position === 'OutsideLeft' ? 'OutsideLeft' : point.labelPosition || position;\n            var location_2 = {\n                x: point.symbolLocation.x,\n                y: point.symbolLocation.y - point.labelOffset.y\n            };\n            switch (position) {\n                case 'Inside':\n                    location_2.y = point.region.y + point.region.height / 2;\n                    break;\n                case 'Outside':\n                    location_2.x += point.labelOffset.x;\n                    break;\n                case 'OutsideLeft':\n                    location_2.x -= point.labelOffset.x;\n            }\n            return location_2;\n        }\n        else {\n            //return degreeToLocation(point.midAngle, this.radius, this.center);\n            return degreeToLocation(point.midAngle, (this.isVariousRadius() ? stringToNumber(point.sliceRadius, this.accumulation.pieSeriesModule.seriesRadius) :\n                this.radius), this.center);\n        }\n    };\n    /**\n     * Finds the beginning of connector line\n     *\n     * @returns {ChartLocation} Staring point of connector line.\n     */\n    AccumulationDataLabel.prototype.getConnectorStartPoint = function (point, connector) {\n        // return this.isCircular() ? degreeToLocation(point.midAngle, this.radius - connector.width, this.center) :\n        //     this.getLabelLocation(point);\n        var position;\n        if (!this.isCircular() && point.region.x > point.labelRegion.x) {\n            position = 'OutsideLeft';\n        }\n        return this.isCircular() ? degreeToLocation(point.midAngle, (this.isVariousRadius() ? stringToNumber(point.sliceRadius, this.accumulation.pieSeriesModule.seriesRadius) :\n            this.radius) - connector.width, this.center) : this.getLabelLocation(point, position);\n    };\n    /**\n     * To find area rect based on margin, available size.\n     *\n     * @private\n     */\n    AccumulationDataLabel.prototype.findAreaRect = function () {\n        this.areaRect = new Rect(0, 0, this.accumulation.availableSize.width, this.accumulation.availableSize.height);\n        var margin = this.accumulation.margin;\n        subtractThickness(this.areaRect, new Thickness(margin.left, margin.right, margin.top, margin.bottom));\n    };\n    /**\n     * To render the data labels from series points.\n     */\n    AccumulationDataLabel.prototype.renderDataLabel = function (point, dataLabel, parent, points, series, templateElement, redraw) {\n        var id = this.accumulation.element.id + '_datalabel_Series_' + series + '_';\n        var datalabelGroup = this.accumulation.renderer.createGroup({ id: id + 'g_' + point.index });\n        point.label = point.originalText || point.y.toString();\n        var border = { width: dataLabel.border.width, color: dataLabel.border.color };\n        var argsFont = (extend({}, getValue('properties', dataLabel.font), null, true));\n        var argsData = {\n            cancel: false, name: textRender, series: this.accumulation.visibleSeries[0], point: point,\n            text: point.label, border: border, color: dataLabel.fill, template: dataLabel.template, font: argsFont\n        };\n        this.accumulation.trigger(textRender, argsData);\n        point.argsData = argsData;\n        var isTemplate = argsData.template !== null;\n        point.labelVisible = !argsData.cancel;\n        point.text = point.label = argsData.text;\n        if (Number(point.label)) {\n            point.label = this.accumulation.intl.formatNumber(+point.label, {\n                useGrouping: this.accumulation.useGroupingSeparator\n            });\n        }\n        this.marginValue = argsData.border.width ? (5 + argsData.border.width) : 1;\n        var childElement = createElement('div', {\n            id: this.accumulation.element.id + '_Series_' + 0 + '_DataLabel_' + point.index,\n            styles: 'position: absolute;background-color:' + argsData.color + ';' +\n                getFontStyle(dataLabel.font) + ';border:' + argsData.border.width + 'px solid ' + argsData.border.color + ';'\n        });\n        this.calculateLabelSize(isTemplate, childElement, point, points, argsData, datalabelGroup, id, dataLabel, redraw);\n    };\n    /**\n     * To calculate label size\n     */\n    AccumulationDataLabel.prototype.calculateLabelSize = function (isTemplate, childElement, point, points, argsData, datalabelGroup, id, dataLabel, redraw, clientRect, isReactCallback) {\n        var textSize = isTemplate ? (isReactCallback ? { width: clientRect.width, height: clientRect.height } : this.getTemplateSize(childElement, point, argsData, redraw, isTemplate, points, datalabelGroup, id, dataLabel)) : measureText(point.label, dataLabel.font);\n        textSize.height += 4; // 4 for calculation with padding for smart label shape\n        textSize.width += 4;\n        point.textSize = textSize;\n        point.templateElement = childElement;\n        this.getDataLabelPosition(point, dataLabel, textSize, points);\n        if (point.labelRegion) {\n            this.correctLabelRegion(point.labelRegion, point.textSize);\n        }\n    };\n    /**\n     * @private\n     */\n    AccumulationDataLabel.prototype.drawDataLabels = function (series, dataLabel, parent, templateElement, redraw) {\n        var angle;\n        var degree;\n        var modifiedPoints = series.leftSidePoints.concat(series.rightSidePoints);\n        modifiedPoints.sort(function (a, b) { return a.index - b.index; });\n        if (series.type === 'Pie' && this.accumulation.enableSmartLabels) {\n            this.extendedLabelsCalculation();\n        }\n        for (var _i = 0, modifiedPoints_1 = modifiedPoints; _i < modifiedPoints_1.length; _i++) {\n            var point = modifiedPoints_1[_i];\n            if (!isNullOrUndefined(point.argsData) && !isNullOrUndefined(point.y)) {\n                this.finalizeDatalabels(point, modifiedPoints, dataLabel);\n                var id = this.accumulation.element.id + '_datalabel_Series_' + 0 + '_';\n                var datalabelGroup = this.accumulation.renderer.createGroup({ id: id + 'g_' + point.index });\n                var dataLabelElement = void 0;\n                var location_3 = void 0;\n                var element = void 0;\n                if (point.visible && point.labelVisible) {\n                    angle = degree = dataLabel.angle;\n                    if (point.argsData.template) {\n                        this.setTemplateStyle(point.templateElement, point, templateElement, dataLabel.font.color, point.color, redraw);\n                    }\n                    else {\n                        location_3 = new ChartLocation(point.labelRegion.x + this.marginValue, point.labelRegion.y\n                            + (point.textSize.height * 3 / 4) + this.marginValue);\n                        element = getElement(id + 'shape_' + point.index);\n                        var startLocation = element ? new ChartLocation(+element.getAttribute('x'), +element.getAttribute('y')) : null;\n                        dataLabelElement = this.accumulation.renderer.drawRectangle(new RectOption(id + 'shape_' + point.index, point.argsData.color, point.argsData.border, 1, point.labelRegion, dataLabel.rx, dataLabel.ry));\n                        appendChildElement(false, datalabelGroup, dataLabelElement, redraw, true, 'x', 'y', startLocation, null, false, false, null, this.accumulation.duration);\n                        var textWidth = point.textSize.width;\n                        var textHeight = point.textSize.height;\n                        var rotate = void 0;\n                        if (angle !== 0 && dataLabel.enableRotation) {\n                            if (point.labelPosition === 'Outside') {\n                                degree = 0;\n                            }\n                            else {\n                                if (point.midAngle >= 90 && point.midAngle <= 270) {\n                                    degree = point.midAngle + 180;\n                                }\n                                else {\n                                    degree = point.midAngle;\n                                }\n                            }\n                            rotate = 'rotate(' + degree + ',' + (location_3.x + (textWidth / 2)) + ','\n                                + (location_3.y - (textHeight / 4)) + ')';\n                        }\n                        else {\n                            if (angle) {\n                                degree = (angle > 360) ? angle - 360 : (angle < -360) ? angle + 360 : angle;\n                            }\n                            else {\n                                degree = 0;\n                            }\n                            rotate = 'rotate(' + degree + ',' + (location_3.x + (textWidth / 2)) + ',' + (location_3.y) + ')';\n                        }\n                        point.transform = rotate;\n                        textElement(this.accumulation.renderer, new TextOption(id + 'text_' + point.index, location_3.x, location_3.y, this.accumulation.enableRtl ? 'end' : 'start', point.label, rotate, 'auto', degree), point.argsData.font, point.argsData.font.color || this.getSaturatedColor(point, point.argsData.color), datalabelGroup, false, redraw, true, false, this.accumulation.duration);\n                        element = null;\n                    }\n                    if (this.accumulation.accumulationLegendModule && this.accumulation.legendSettings.visible && (dataLabel.position === 'Outside'\n                        || this.accumulation.enableSmartLabels)) {\n                        this.accumulation.visibleSeries[0].findMaxBounds(this.accumulation.visibleSeries[0].labelBound, point.labelRegion);\n                    }\n                    if (point.labelPosition === 'Outside') {\n                        var element_1 = getElement(id + 'connector_' + point.index);\n                        var previousDirection = element_1 ? element_1.getAttribute('d') : '';\n                        var pathElement = this.accumulation.renderer.drawPath(new PathOption(id + 'connector_' + point.index, 'transparent', dataLabel.connectorStyle.width, dataLabel.connectorStyle.color || point.color, 1, dataLabel.connectorStyle.dashArray, this.getConnectorPath(extend({}, point.labelRegion, null, true), point, dataLabel, point.labelAngle)));\n                        appendChildElement(false, datalabelGroup, pathElement, redraw, true, null, null, null, previousDirection, false, false, null, this.accumulation.duration);\n                    }\n                    appendChildElement(false, parent, datalabelGroup, redraw);\n                }\n            }\n        }\n    };\n    /**\n     * In this method datalabels region checked with legebdBounds and areaBounds.\n     * Trimming of datalabel and point's visibility again changed here.\n     *\n     * @param {AccPoints} point current point in which trimming and visibility to be checked\n     * @param {AccPoints[]} points finalized points\n     * @param {AccumulationDataLabelSettingsModel} dataLabel datalabel model\n     */\n    AccumulationDataLabel.prototype.finalizeDatalabels = function (point, points, dataLabel) {\n        if (this.isOverlapping(point, points) ||\n            (this.titleRect && point.labelRegion && isOverlap(point.labelRegion, this.titleRect))) {\n            if (this.isCircular() && point.labelPosition === 'Outside') {\n                this.setPointVisibileFalse(point);\n            }\n        }\n        if (this.accumulation.accumulationLegendModule && this.accumulation.legendSettings.visible && point.labelVisible && point.labelRegion) {\n            var rect = this.accumulation.accumulationLegendModule.legendBounds;\n            if (this.accumulation.visibleSeries[0].type != \"Pie\" && this.accumulation.legendSettings.position == 'Left'\n                && dataLabel.position === 'Outside') {\n                point.labelRegion.x = point.labelRegion.x + rect.width;\n            }\n            var padding = this.accumulation.legendSettings.border.width / 2;\n            this.textTrimming(point, new Rect(rect.x - padding, rect.y - padding, rect.width + (2 * padding), rect.height + (2 * padding)), dataLabel.font, this.accumulation.accumulationLegendModule.position);\n        }\n        if (point.labelVisible && point.labelRegion) {\n            var position = this.isCircular() ? (point.labelRegion.x >= this.center.x) ? 'InsideRight' : 'InsideLeft' :\n                (point.labelRegion.x >= point.region.x) ? 'InsideRight' : 'InsideLeft';\n            this.textTrimming(point, this.areaRect, dataLabel.font, position);\n        }\n        if (point.labelVisible && point.labelRegion && ((point.labelRegion.y + point.labelRegion.height >\n            this.areaRect.y + this.areaRect.height || point.labelRegion.y < this.areaRect.y) || (point.labelRegion.x < this.areaRect.x ||\n            point.labelRegion.x + point.labelRegion.width > this.areaRect.x + this.areaRect.width))) {\n            this.setPointVisibileFalse(point);\n        }\n    };\n    /**\n     * To find the template element size\n     *\n     * @param {HTMLElement} element To get a template element.\n     * @param {AccPoints} point Template of accumulation points.\n     * @param {IAccTextRenderEventArgs} argsData Arguments of accumulation points.\n     * @param {boolean} redraw redraw value.\n     * @returns {Size} Size of a template.\n     */\n    AccumulationDataLabel.prototype.getTemplateSize = function (element, point, argsData, redraw, isTemplate, points, datalabelGroup, id, dataLabel) {\n        element = createTemplate(element, point.index, argsData.template, this.accumulation, point, this.accumulation.visibleSeries[0], this.accumulation.element.id + '_DataLabel', 0, argsData, isTemplate, points, datalabelGroup, id, dataLabel, redraw);\n        var clientRect = measureElementRect(element, redraw);\n        return { width: clientRect.width, height: clientRect.height };\n    };\n    /**\n     * To set the template element style\n     *\n     * @param {HTMLElement} childElement Set a child element of template.\n     * @param {AccPoints} point Template point.\n     * @param {parent} parent Parent element of template.\n     * @param {labelColor} labelColor Template label color.\n     * @param {string} fill Fill color of template.\n     */\n    AccumulationDataLabel.prototype.setTemplateStyle = function (childElement, point, parent, labelColor, fill, redraw) {\n        childElement.style.left = (point.labelRegion.x) + 'px';\n        childElement.style.top = (point.labelRegion.y) + 'px';\n        childElement.style.color = labelColor ||\n            this.getSaturatedColor(point, fill);\n        if (this.accumulation.isBlazor) {\n            var position = this.isCircular() ? (point.labelRegion.x >= this.center.x) ? 'InsideRight' : 'InsideLeft' :\n                (point.labelRegion.x >= point.region.x) ? 'InsideRight' : 'InsideLeft';\n            if (position === 'InsideRight') {\n                childElement.style.transform = 'translate(0%, -50%)';\n            }\n            else {\n                childElement.style.transform = 'translate(-100%, -50%)';\n            }\n        }\n        if (childElement.childElementCount) {\n            appendChildElement(false, parent, childElement, redraw, true, 'left', 'top');\n            this.doTemplateAnimation(this.accumulation, childElement);\n        }\n    };\n    /**\n     * To find saturated color for datalabel\n     *\n     * @returns {string} Get a saturated color.\n     */\n    AccumulationDataLabel.prototype.getSaturatedColor = function (point, color) {\n        var saturatedColor;\n        if (this.marginValue >= 1) {\n            saturatedColor = color === 'transparent' ? this.getLabelBackground(point) : color;\n        }\n        else {\n            saturatedColor = this.getLabelBackground(point);\n        }\n        saturatedColor = (saturatedColor === 'transparent') ? window.getComputedStyle(document.body, null).backgroundColor : saturatedColor;\n        var rgbValue = convertHexToColor(colorNameToHex(saturatedColor));\n        var contrast = Math.round((rgbValue.r * 299 + rgbValue.g * 587 + rgbValue.b * 114) / 1000);\n        return contrast >= 128 ? 'black' : 'white';\n    };\n    /**\n     * Animates the data label template.\n     *\n     * @returns {void}\n     * @private\n     */\n    AccumulationDataLabel.prototype.doTemplateAnimation = function (accumulation, element) {\n        var series = accumulation.visibleSeries[0];\n        var delay = series.animation.delay + series.animation.duration;\n        if (series.animation.enable && accumulation.animateSeries) {\n            element.style.visibility = 'hidden';\n            templateAnimate(element, delay, 200, 'ZoomIn');\n        }\n    };\n    /**\n     * To find background color for the datalabel\n     *\n     * @returns {string} AccPoints\n     */\n    AccumulationDataLabel.prototype.getLabelBackground = function (point) {\n        return point.labelPosition === 'Outside' ?\n            this.accumulation.background || this.accumulation.themeStyle.background : !point.y ? this.accumulation.theme.indexOf('dark') ? 'white' : 'black' : point.color;\n    };\n    /**\n     * To correct the padding between datalabel regions.\n     */\n    AccumulationDataLabel.prototype.correctLabelRegion = function (labelRegion, textSize, padding) {\n        if (padding === void 0) { padding = 4; }\n        labelRegion.height -= padding;\n        labelRegion.width -= padding;\n        labelRegion.x += padding / 2;\n        labelRegion.y += padding / 2;\n        textSize.height -= padding;\n        textSize.width -= padding;\n    };\n    /**\n     * To get the dataLabel module name\n     *\n     * @returns {string} module name\n     */\n    AccumulationDataLabel.prototype.getModuleName = function () {\n        return 'AccumulationDataLabel';\n    };\n    /**\n     * To destroy the data label.\n     *\n     * @returns {void}\n     * @private\n     */\n    AccumulationDataLabel.prototype.destroy = function () {\n        /**\n         * Destroy method performed here\n         */\n    };\n    //calculation for placing labels smartly\n    AccumulationDataLabel.prototype.extendedLabelsCalculation = function () {\n        var _this = this;\n        var series = this.accumulation.series[0];\n        series.rightSidePoints.forEach(function (point, index, halfSidePoints) {\n            point.initialLabelRegion = point.labelRegion;\n            point.isLabelUpdated = 0;\n            _this.skipPoints(point, halfSidePoints, index);\n        });\n        series.leftSidePoints.forEach(function (point, index, halfSidePoints) {\n            point.initialLabelRegion = point.labelRegion;\n            point.isLabelUpdated = 0;\n            _this.skipPoints(point, halfSidePoints, index);\n        });\n        this.arrangeLeftSidePoints(series);\n        this.isIncreaseAngle = false;\n        this.arrangeRightSidePoints(series);\n    };\n    /**\n     * Rightside points alignments calculation\n     *\n     * @param {AccumulationSeries} series To get a proper series.\n     */\n    AccumulationDataLabel.prototype.arrangeRightSidePoints = function (series) {\n        var startFresh;\n        var angleChanged;\n        var rightSideRenderPoints = series.rightSidePoints.filter(function (point) { return (point.labelVisible && point.labelPosition === 'Outside'); });\n        this.rightSideRenderingPoints = rightSideRenderPoints;\n        var checkAngle;\n        var currentPoint;\n        var lastPoint = rightSideRenderPoints[rightSideRenderPoints.length - 1];\n        var nextPoint;\n        if (lastPoint) {\n            if (lastPoint.labelAngle > 90 && lastPoint.labelAngle < 270) {\n                this.isIncreaseAngle = true;\n                this.changeLabelAngle(lastPoint, 89);\n            }\n        }\n        /**\n         * Right side points arranged from last point.\n         * A point checked with successive points for overlapping.\n         * If that is overlapped, its label angle is decreased and placing in optimal position\n         * If one point's angle is decreased, its previous points in the half side points also decreased until it reaced optimum position.\n         * When decreasing angle falls beyond 270, label angle increased.\n         * If one point's angle is increased, its successive points in that half point also increased until it reaced optimum position.\n         */\n        for (var i = rightSideRenderPoints.length - 1; i >= 0; i--) {\n            currentPoint = rightSideRenderPoints[i];\n            nextPoint = rightSideRenderPoints[i + 1];\n            // A point checked for overlapping, label visibility\n            if (this.isOverlapWithNext(currentPoint, rightSideRenderPoints, i) && currentPoint.labelVisible\n                || !(currentPoint.labelAngle <= 90 || currentPoint.labelAngle >= 270)) {\n                checkAngle = lastPoint.labelAngle + 10;\n                angleChanged = true;\n                //If last's point change angle in beyond the limit, stop the increasing angle and do decrease the angle.\n                if (startFresh) {\n                    this.isIncreaseAngle = false;\n                }\n                else if (checkAngle > 90 && checkAngle < 270 && nextPoint.isLabelUpdated) {\n                    this.isIncreaseAngle = true;\n                }\n                if (!this.isIncreaseAngle) {\n                    for (var k = i + 1; k < rightSideRenderPoints.length; k++) {\n                        this.increaseAngle(rightSideRenderPoints[k - 1], rightSideRenderPoints[k], series, true);\n                    }\n                }\n                else {\n                    for (var k = i + 1; k > 0; k--) {\n                        this.decreaseAngle(rightSideRenderPoints[k], rightSideRenderPoints[k - 1], series, true);\n                    }\n                }\n            }\n            else {\n                //If a point did not overlapped with previous points, increase the angle always for right side points.\n                if (angleChanged && nextPoint && !nextPoint.isLabelUpdated) {\n                    startFresh = true;\n                }\n            }\n        }\n    };\n    /**\n     * Leftside points alignments calculation\n     *\n     * @param {AccumulationSeries} series To get a proper series.\n     */\n    AccumulationDataLabel.prototype.arrangeLeftSidePoints = function (series) {\n        var _this = this;\n        var leftSideRenderPoints = series.leftSidePoints.filter(function (point) { return (point.labelVisible && point.labelPosition === 'Outside'); });\n        this.leftSideRenderingPoints = leftSideRenderPoints;\n        var previousPoint;\n        var currentPoint;\n        var angleChanged;\n        var startFresh;\n        /**\n         * Left side points arranged from first point.\n         * A point checked with previous points for overlapping.\n         * If that is overlapped, its label angle is decreased and placing in optimal position\n         * If one point's angle is decreased, its previous points in the half side points also decreased until it reaced optimum position.\n         * When decreasing angle falls beyond 90, label angle increased.\n         * If one point's angle is increased, its successive points in that half point also increased until it reaced optimum position.\n         */\n        for (var i = 0; i < leftSideRenderPoints.length; i++) {\n            currentPoint = leftSideRenderPoints[i];\n            previousPoint = leftSideRenderPoints[i - 1];\n            // A point checked\n            if (this.isOverlapWithPrevious(currentPoint, leftSideRenderPoints, i) && currentPoint.labelVisible\n                || !(currentPoint.labelAngle < 270)) {\n                angleChanged = true;\n                if (startFresh) {\n                    this.isIncreaseAngle = false;\n                }\n                if (!this.isIncreaseAngle) {\n                    for (var k = i; k > 0; k--) {\n                        this.decreaseAngle(leftSideRenderPoints[k], leftSideRenderPoints[k - 1], series, false);\n                        leftSideRenderPoints.filter(function (point, index) {\n                            if (point.isLabelUpdated && leftSideRenderPoints[index].labelAngle - 10 < 100) {\n                                _this.isIncreaseAngle = true;\n                            }\n                        });\n                    }\n                }\n                else {\n                    for (var k = i; k < leftSideRenderPoints.length; k++) {\n                        this.increaseAngle(leftSideRenderPoints[k - 1], leftSideRenderPoints[k], series, false);\n                    }\n                }\n            }\n            else {\n                if (angleChanged && previousPoint && previousPoint.isLabelUpdated) {\n                    startFresh = true;\n                }\n            }\n        }\n    };\n    AccumulationDataLabel.prototype.decreaseAngle = function (currentPoint, previousPoint, series, isRightSide) {\n        if (isNullOrUndefined(currentPoint) || isNullOrUndefined(previousPoint)) {\n            return null;\n        }\n        var count = 1;\n        if (isRightSide) {\n            while (isOverlap(currentPoint.labelRegion, previousPoint.labelRegion) || (!this.isVariousRadius() &&\n                !((previousPoint.labelRegion.height + previousPoint.labelRegion.y) < currentPoint.labelRegion.y))) {\n                var newAngle = previousPoint.midAngle - count;\n                if (newAngle < 0) {\n                    newAngle = 360 + newAngle;\n                }\n                if (newAngle <= 270 && newAngle >= 90) {\n                    newAngle = 270;\n                    this.isIncreaseAngle = true;\n                    break;\n                }\n                this.changeLabelAngle(previousPoint, newAngle);\n                count++;\n            }\n        }\n        else {\n            if (currentPoint.labelAngle > 270) {\n                this.changeLabelAngle(currentPoint, 270);\n                previousPoint.labelAngle = 270;\n            }\n            while (isOverlap(currentPoint.labelRegion, previousPoint.labelRegion) || (!this.isVariousRadius() &&\n                ((currentPoint.labelRegion.y + currentPoint.labelRegion.height) > previousPoint.labelRegion.y))) {\n                var newAngle = previousPoint.midAngle - count;\n                if (!(newAngle <= 270 && newAngle >= 90)) {\n                    newAngle = 90;\n                    this.isIncreaseAngle = true;\n                    break;\n                }\n                this.changeLabelAngle(previousPoint, newAngle);\n                if (isOverlap(currentPoint.labelRegion, previousPoint.labelRegion) &&\n                    !series.leftSidePoints.indexOf(previousPoint) && (newAngle - 1 < 90 && newAngle - 1 > 270)) {\n                    this.changeLabelAngle(currentPoint, currentPoint.labelAngle + 1);\n                    this.arrangeLeftSidePoints(series);\n                    break;\n                }\n                count++;\n            }\n        }\n    };\n    AccumulationDataLabel.prototype.increaseAngle = function (currentPoint, nextPoint, series, isRightSide) {\n        if (isNullOrUndefined(currentPoint) || isNullOrUndefined(nextPoint)) {\n            return null;\n        }\n        var count = 1;\n        if (isRightSide) {\n            while (isOverlap(currentPoint.labelRegion, nextPoint.labelRegion) || (!this.isVariousRadius() &&\n                !((currentPoint.labelRegion.y + currentPoint.labelRegion.height) < nextPoint.labelRegion.y))) {\n                var newAngle = nextPoint.midAngle + count;\n                if (newAngle < 270 && newAngle > 90) {\n                    newAngle = 90;\n                    this.isIncreaseAngle = true;\n                    break;\n                }\n                this.changeLabelAngle(nextPoint, newAngle);\n                if (isOverlap(currentPoint.labelRegion, nextPoint.labelRegion) && (newAngle + 1 > 90 && newAngle + 1 < 270) &&\n                    this.rightSideRenderingPoints.indexOf(nextPoint) === this.rightSideRenderingPoints.length - 1) {\n                    this.changeLabelAngle(currentPoint, currentPoint.labelAngle - 1);\n                    nextPoint.labelRegion = nextPoint.initialLabelRegion;\n                    this.arrangeRightSidePoints(series);\n                    break;\n                }\n                count++;\n            }\n        }\n        else {\n            while (isOverlap(currentPoint.labelRegion, nextPoint.labelRegion) || (!this.isVariousRadius() &&\n                (currentPoint.labelRegion.y < (nextPoint.labelRegion.y + nextPoint.labelRegion.height)))) {\n                var newAngle = nextPoint.midAngle + count;\n                if (!(newAngle < 270 && newAngle > 90)) {\n                    newAngle = 270;\n                    this.isIncreaseAngle = false;\n                    break;\n                }\n                this.changeLabelAngle(nextPoint, newAngle);\n                count++;\n            }\n        }\n    };\n    AccumulationDataLabel.prototype.changeLabelAngle = function (currentPoint, newAngle) {\n        var dataLabel = this.accumulation.series[0].dataLabel;\n        var variableR;\n        if (this.isVariousRadius()) {\n            variableR = this.accumulation.pieSeriesModule.getLabelRadius(this.accumulation.visibleSeries[0], currentPoint);\n        }\n        //padding 10px is added to label radius for increasing the angle and avoid congestion.\n        var labelRadius = (currentPoint.labelPosition === 'Outside' && this.accumulation.enableSmartLabels &&\n            dataLabel.position === 'Inside') ?\n            this.radius + stringToNumber(dataLabel.connectorStyle.length || '4%', this.accumulation.pieSeriesModule.size / 2) :\n            (!this.isVariousRadius() ? this.accumulation.pieSeriesModule.labelRadius + 10 : variableR);\n        var radius = (!this.isVariousRadius() ? labelRadius : variableR);\n        this.getLabelRegion(currentPoint, 'Outside', currentPoint.textSize, radius, this.marginValue, newAngle);\n        currentPoint.isLabelUpdated = 1;\n        currentPoint.labelAngle = newAngle;\n    };\n    AccumulationDataLabel.prototype.isOverlapWithPrevious = function (currentPoint, points, currentPointIndex) {\n        for (var i = 0; i < currentPointIndex; i++) {\n            if (i !== points.indexOf(currentPoint) &&\n                points[i].visible && points[i].labelVisible && points[i].labelRegion && currentPoint.labelRegion &&\n                currentPoint.labelVisible && isOverlap(currentPoint.labelRegion, points[i].labelRegion)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    AccumulationDataLabel.prototype.isOverlapWithNext = function (point, points, pointIndex) {\n        for (var i = pointIndex; i < points.length; i++) {\n            if (i !== points.indexOf(point) && points[i].visible && points[i].labelVisible && points[i].labelRegion &&\n                point.labelRegion && point.labelVisible && isOverlap(point.labelRegion, points[i].labelRegion)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    AccumulationDataLabel.prototype.skipPoints = function (currentPoint, halfsidePoints, pointIndex) {\n        if (pointIndex > 0 && ((currentPoint.midAngle < 285 && currentPoint.midAngle > 255) ||\n            (currentPoint.midAngle < 105 && currentPoint.midAngle > 75))) {\n            var previousPoint = halfsidePoints[pointIndex - 1];\n            var angleDiff = currentPoint.endAngle % 360 - currentPoint.startAngle % 360;\n            var prevAngleDiff = previousPoint.endAngle % 360 - previousPoint.startAngle % 360;\n            if (prevAngleDiff <= angleDiff && angleDiff < 5 && previousPoint.labelVisible) {\n                this.setPointVisibleTrue(currentPoint);\n            }\n        }\n        else if (pointIndex > 1 && ((currentPoint.midAngle < 300 && currentPoint.midAngle > 240) ||\n            (currentPoint.midAngle < 120 && currentPoint.midAngle > 60))) {\n            var prevPoint = halfsidePoints[pointIndex - 1];\n            var secondPrevPoint = halfsidePoints[pointIndex - 2];\n            var angleDiff = currentPoint.endAngle % 360 - currentPoint.startAngle % 360;\n            var prevAngleDiff = prevPoint.endAngle % 360 - prevPoint.startAngle % 360;\n            var thirdAngleDiff = secondPrevPoint.endAngle % 360 - secondPrevPoint.startAngle % 360;\n            if (angleDiff < 3 && prevAngleDiff < 3 && thirdAngleDiff < 3 && prevPoint.labelVisible && currentPoint.labelVisible) {\n                this.setPointVisibleTrue(currentPoint);\n            }\n        }\n    };\n    AccumulationDataLabel.prototype.getPerpendicularDistance = function (startPoint, point) {\n        var increasedLocation;\n        var add = 10;\n        var height = add + 10 * Math.sin(point.midAngle * Math.PI / 360);\n        if (point.midAngle > 270 && point.midAngle < 360) {\n            increasedLocation = new ChartLocation(startPoint.x + height * (Math.cos((360 - point.midAngle) * Math.PI / 180)), startPoint.y - height * (Math.sin((360 - point.midAngle) * Math.PI / 180)));\n        }\n        else if (point.midAngle > 0 && point.midAngle < 90) {\n            increasedLocation = new ChartLocation(startPoint.x + height * (Math.cos((point.midAngle) * Math.PI / 180)), startPoint.y + height * (Math.sin((point.midAngle) * Math.PI / 180)));\n        }\n        else if (point.midAngle > 0 && point.midAngle < 90) {\n            increasedLocation = new ChartLocation(startPoint.x - height * (Math.cos((point.midAngle - 90) * Math.PI / 180)), startPoint.y + height * (Math.sin((point.midAngle - 90) * Math.PI / 180)));\n        }\n        else {\n            increasedLocation = new ChartLocation(startPoint.x - height * (Math.cos((point.midAngle - 180) * Math.PI / 180)), startPoint.y - height * (Math.sin((point.midAngle - 180) * Math.PI / 180)));\n        }\n        return increasedLocation;\n    };\n    return AccumulationDataLabel;\n}(AccumulationBase));\nexport { AccumulationDataLabel };\n"]},"metadata":{},"sourceType":"module"}