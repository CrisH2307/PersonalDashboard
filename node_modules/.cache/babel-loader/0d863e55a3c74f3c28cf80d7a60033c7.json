{"ast":null,"code":"/* eslint-disable jsdoc/require-returns */\n\n/* eslint-disable @typescript-eslint/no-inferrable-types */\n\n/* eslint-disable jsdoc/require-param */\n\n/* eslint-disable valid-jsdoc */\n\n/**\n * Defines the behavior of a pyramid series\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { removeElement } from '@syncfusion/ej2-svg-base';\nimport { appendChildElement } from '../../common/utils/helper';\nimport { TriangularBase } from './triangular-base';\n/**\n * PyramidSeries module used to render `Pyramid` Series.\n */\n\nvar PyramidSeries =\n/** @class */\nfunction (_super) {\n  __extends(PyramidSeries, _super);\n\n  function PyramidSeries() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * Defines the path of a pyramid segment\n   */\n\n\n  PyramidSeries.prototype.getSegmentData = function (point, series, chart) {\n    var area = series.triangleSize; //top of th series\n\n    var seriesTop = chart.initialClipRect.y + (chart.initialClipRect.height - area.height) / 2; //consider, if the point is exploded\n\n    var offset = 0;\n    var extraSpace = (chart.initialClipRect.width - series.triangleSize.width) / 2;\n    var emptySpaceAtLeft = extraSpace + chart.initialClipRect.x; //top and bottom\n\n    var top = point.yRatio;\n    var bottom = point.yRatio + point.heightRatio; //width of the top and bottom edge\n\n    var topRadius = 0.5 * (1 - point.yRatio);\n    var bottomRadius = 0.5 * (1 - bottom);\n    top += seriesTop / area.height;\n    bottom += seriesTop / area.height;\n    var line1 = {\n      x: emptySpaceAtLeft + offset + topRadius * area.width,\n      y: top * area.height\n    };\n    var line2 = {\n      x: emptySpaceAtLeft + offset + (1 - topRadius) * area.width,\n      y: top * area.height\n    };\n    var line3 = {\n      x: emptySpaceAtLeft + offset + (1 - bottomRadius) * area.width,\n      y: bottom * area.height\n    };\n    var line4 = {\n      x: emptySpaceAtLeft + offset + bottomRadius * area.width,\n      y: bottom * area.height\n    };\n    var polygon = [line1, line2, line3, line4];\n    this.setLabelLocation(series, point, polygon);\n    var direction = this.findPath(polygon);\n    return direction;\n  };\n  /**\n   * Initializes the size of the pyramid segments\n   *\n   * @private\n   */\n\n\n  PyramidSeries.prototype.initializeSizeRatio = function (points, series) {\n    if (series.pyramidMode === 'Linear') {\n      _super.prototype.initializeSizeRatio.call(this, points, series, true);\n    } else {\n      this.calculateSurfaceSegments(series);\n    }\n  };\n  /**\n   * Defines the size of the pyramid segments, the surface of that will reflect the values\n   */\n\n\n  PyramidSeries.prototype.calculateSurfaceSegments = function (series) {\n    var count = series.points.length;\n    var sumOfValues = series.sumOfPoints;\n    var y = [];\n    var height = [];\n    var gapRatio = Math.min(0, Math.max(series.gapRatio, 1));\n    var gapHeight = gapRatio / (count - 1);\n    var preSum = this.getSurfaceHeight(0, sumOfValues);\n    var currY = 0;\n\n    for (var i = 0; i < count; i++) {\n      if (series.points[i].visible) {\n        y[i] = currY;\n        height[i] = this.getSurfaceHeight(currY, Math.abs(series.points[i].y));\n        currY += height[i] + gapHeight * preSum;\n      }\n    }\n\n    var coef = 1 / (currY - gapHeight * preSum);\n\n    for (var i = 0; i < count; i++) {\n      if (series.points[i].visible) {\n        series.points[i].yRatio = coef * y[i];\n        series.points[i].heightRatio = coef * height[i];\n      }\n    }\n  };\n  /**\n   * Finds the height of pyramid segment\n   */\n\n\n  PyramidSeries.prototype.getSurfaceHeight = function (y, surface) {\n    var result = this.solveQuadraticEquation(1, 2 * y, -surface);\n    return result;\n  };\n  /**\n   * Solves quadratic equation\n   */\n\n\n  PyramidSeries.prototype.solveQuadraticEquation = function (a, b, c) {\n    var root1;\n    var root2;\n    var d = b * b - 4 * a * c;\n\n    if (d >= 0) {\n      var sd = Math.sqrt(d);\n      root1 = (-b - sd) / (2 * a);\n      root2 = (-b + sd) / (2 * a);\n      return Math.max(root1, root2);\n    }\n\n    return 0;\n  };\n  /**\n   * Renders a pyramid segment\n   */\n\n\n  PyramidSeries.prototype.renderPoint = function (point, series, chart, options, seriesGroup, redraw) {\n    if (!point.visible) {\n      removeElement(options.id);\n      return null;\n    }\n\n    options.d = this.getSegmentData(point, series, chart);\n    point.midAngle = 0;\n    appendChildElement(false, seriesGroup, chart.renderer.drawPath(options), redraw);\n\n    if (point.isExplode) {\n      chart.accBaseModule.explodePoints(point.index, chart, true);\n    }\n  };\n  /**\n   * To get the module name of the Pyramid series.\n   */\n\n\n  PyramidSeries.prototype.getModuleName = function () {\n    return 'PyramidSeries';\n  };\n  /**\n   * To destroy the pyramid series\n   *\n   * @returns {void}\n   * @private\n   */\n\n\n  PyramidSeries.prototype.destroy = function () {\n    /**\n     * Destroys the pyramid series\n     */\n  };\n\n  return PyramidSeries;\n}(TriangularBase);\n\nexport { PyramidSeries };","map":{"version":3,"sources":["C:/Users/khang/OneDrive/Tài liệu/JS/PersonalDashdoard/dashboard/node_modules/@syncfusion/ej2-react-charts/node_modules/@syncfusion/ej2-charts/src/accumulation-chart/renderer/pyramid-series.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","removeElement","appendChildElement","TriangularBase","PyramidSeries","_super","apply","arguments","getSegmentData","point","series","chart","area","triangleSize","seriesTop","initialClipRect","y","height","offset","extraSpace","width","emptySpaceAtLeft","x","top","yRatio","bottom","heightRatio","topRadius","bottomRadius","line1","line2","line3","line4","polygon","setLabelLocation","direction","findPath","initializeSizeRatio","points","pyramidMode","call","calculateSurfaceSegments","count","length","sumOfValues","sumOfPoints","gapRatio","Math","min","max","gapHeight","preSum","getSurfaceHeight","currY","i","visible","abs","coef","surface","result","solveQuadraticEquation","a","c","root1","root2","sd","sqrt","renderPoint","options","seriesGroup","redraw","id","midAngle","renderer","drawPath","isExplode","accBaseModule","explodePoints","index","getModuleName","destroy"],"mappings":"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","sourcesContent":["/* eslint-disable jsdoc/require-returns */\n/* eslint-disable @typescript-eslint/no-inferrable-types */\n/* eslint-disable jsdoc/require-param */\n/* eslint-disable valid-jsdoc */\n/**\n * Defines the behavior of a pyramid series\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { removeElement } from '@syncfusion/ej2-svg-base';\nimport { appendChildElement } from '../../common/utils/helper';\nimport { TriangularBase } from './triangular-base';\n/**\n * PyramidSeries module used to render `Pyramid` Series.\n */\nvar PyramidSeries = /** @class */ (function (_super) {\n    __extends(PyramidSeries, _super);\n    function PyramidSeries() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * Defines the path of a pyramid segment\n     */\n    PyramidSeries.prototype.getSegmentData = function (point, series, chart) {\n        var area = series.triangleSize;\n        //top of th series\n        var seriesTop = chart.initialClipRect.y + (chart.initialClipRect.height - area.height) / 2;\n        //consider, if the point is exploded\n        var offset = 0;\n        var extraSpace = (chart.initialClipRect.width - series.triangleSize.width) / 2;\n        var emptySpaceAtLeft = extraSpace + chart.initialClipRect.x;\n        //top and bottom\n        var top = point.yRatio;\n        var bottom = point.yRatio + point.heightRatio;\n        //width of the top and bottom edge\n        var topRadius = 0.5 * (1 - point.yRatio);\n        var bottomRadius = 0.5 * (1 - bottom);\n        top += seriesTop / area.height;\n        bottom += seriesTop / area.height;\n        var line1 = {\n            x: emptySpaceAtLeft + offset + topRadius * area.width,\n            y: top * area.height\n        };\n        var line2 = {\n            x: emptySpaceAtLeft + offset + (1 - topRadius) * area.width,\n            y: top * area.height\n        };\n        var line3 = {\n            x: emptySpaceAtLeft + offset + (1 - bottomRadius) * area.width,\n            y: bottom * area.height\n        };\n        var line4 = {\n            x: emptySpaceAtLeft + offset + bottomRadius * area.width,\n            y: bottom * area.height\n        };\n        var polygon = [line1, line2, line3, line4];\n        this.setLabelLocation(series, point, polygon);\n        var direction = this.findPath(polygon);\n        return direction;\n    };\n    /**\n     * Initializes the size of the pyramid segments\n     *\n     * @private\n     */\n    PyramidSeries.prototype.initializeSizeRatio = function (points, series) {\n        if (series.pyramidMode === 'Linear') {\n            _super.prototype.initializeSizeRatio.call(this, points, series, true);\n        }\n        else {\n            this.calculateSurfaceSegments(series);\n        }\n    };\n    /**\n     * Defines the size of the pyramid segments, the surface of that will reflect the values\n     */\n    PyramidSeries.prototype.calculateSurfaceSegments = function (series) {\n        var count = series.points.length;\n        var sumOfValues = series.sumOfPoints;\n        var y = [];\n        var height = [];\n        var gapRatio = Math.min(0, Math.max(series.gapRatio, 1));\n        var gapHeight = gapRatio / (count - 1);\n        var preSum = this.getSurfaceHeight(0, sumOfValues);\n        var currY = 0;\n        for (var i = 0; i < count; i++) {\n            if (series.points[i].visible) {\n                y[i] = currY;\n                height[i] = this.getSurfaceHeight(currY, Math.abs(series.points[i].y));\n                currY += height[i] + gapHeight * preSum;\n            }\n        }\n        var coef = 1 / (currY - gapHeight * preSum);\n        for (var i = 0; i < count; i++) {\n            if (series.points[i].visible) {\n                series.points[i].yRatio = coef * y[i];\n                series.points[i].heightRatio = coef * height[i];\n            }\n        }\n    };\n    /**\n     * Finds the height of pyramid segment\n     */\n    PyramidSeries.prototype.getSurfaceHeight = function (y, surface) {\n        var result = this.solveQuadraticEquation(1, 2 * y, -surface);\n        return result;\n    };\n    /**\n     * Solves quadratic equation\n     */\n    PyramidSeries.prototype.solveQuadraticEquation = function (a, b, c) {\n        var root1;\n        var root2;\n        var d = b * b - 4 * a * c;\n        if (d >= 0) {\n            var sd = Math.sqrt(d);\n            root1 = (-b - sd) / (2 * a);\n            root2 = (-b + sd) / (2 * a);\n            return Math.max(root1, root2);\n        }\n        return 0;\n    };\n    /**\n     * Renders a pyramid segment\n     */\n    PyramidSeries.prototype.renderPoint = function (point, series, chart, options, seriesGroup, redraw) {\n        if (!point.visible) {\n            removeElement(options.id);\n            return null;\n        }\n        options.d = this.getSegmentData(point, series, chart);\n        point.midAngle = 0;\n        appendChildElement(false, seriesGroup, chart.renderer.drawPath(options), redraw);\n        if (point.isExplode) {\n            chart.accBaseModule.explodePoints(point.index, chart, true);\n        }\n    };\n    /**\n     * To get the module name of the Pyramid series.\n     */\n    PyramidSeries.prototype.getModuleName = function () {\n        return 'PyramidSeries';\n    };\n    /**\n     * To destroy the pyramid series\n     *\n     * @returns {void}\n     * @private\n     */\n    PyramidSeries.prototype.destroy = function () {\n        /**\n         * Destroys the pyramid series\n         */\n    };\n    return PyramidSeries;\n}(TriangularBase));\nexport { PyramidSeries };\n"]},"metadata":{},"sourceType":"module"}