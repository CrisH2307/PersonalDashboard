{"ast":null,"code":"import { SizeF, RectangleF, PointF } from './../../drawing/pdf-drawing';\nimport { PdfWordWrapType } from './enum';\nimport { StringTokenizer } from './string-tokenizer';\n/**\n * Class `lay outing the text`.\n */\n\nvar PdfStringLayouter =\n/** @class */\nfunction () {\n  // Constructors\n\n  /**\n   * Initializes a new instance of the `StringLayouter` class.\n   * @private\n   */\n  function PdfStringLayouter() {\n    /**\n     * Checks whether the x co-ordinate is need to set as client size or not.\n     * @hidden\n     * @private\n     */\n    this.isOverloadWithPosition = false; //\n  }\n\n  PdfStringLayouter.prototype.layout = function (arg1, arg2, arg3, arg4, arg5, arg6, arg7) {\n    if (arg4 instanceof RectangleF) {\n      this.initialize(arg1, arg2, arg3, arg4, arg5);\n      this.isOverloadWithPosition = arg6;\n      this.clientSize = arg7;\n      var result = this.doLayout();\n      this.clear();\n      return result;\n    } else {\n      this.initialize(arg1, arg2, arg3, arg4);\n      this.isOverloadWithPosition = arg5;\n      this.clientSize = arg6;\n      var result = this.doLayout();\n      this.clear();\n      return result;\n    }\n  };\n\n  PdfStringLayouter.prototype.initialize = function (text, font, format, rectSize, pageHeight) {\n    if (typeof pageHeight === 'number') {\n      if (text == null) {\n        throw new Error('ArgumentNullException:text');\n      }\n\n      if (font == null) {\n        throw new Error('ArgumentNullException:font');\n      }\n\n      this.text = text;\n      this.font = font;\n      this.format = format;\n      this.size = new SizeF(rectSize.width, rectSize.height);\n      this.rectangle = rectSize;\n      this.pageHeight = pageHeight;\n      this.reader = new StringTokenizer(text);\n    } else {\n      this.initialize(text, font, format, new RectangleF(new PointF(0, 0), rectSize), 0);\n    }\n  };\n  /**\n   * `Clear` all resources.\n   * @private\n   */\n\n\n  PdfStringLayouter.prototype.clear = function () {\n    this.font = null;\n    this.format = null;\n    this.reader.close();\n    this.reader = null;\n    this.text = null;\n  };\n  /**\n   * `Layouts` the text.\n   * @private\n   */\n\n\n  PdfStringLayouter.prototype.doLayout = function () {\n    var result = new PdfStringLayoutResult();\n    var lineResult = new PdfStringLayoutResult();\n    var lines = [];\n    var line = this.reader.peekLine();\n    var lineIndent = this.getLineIndent(true);\n\n    while (line != null) {\n      lineResult = this.layoutLine(line, lineIndent);\n\n      if (lineResult !== null || typeof lineResult !== 'undefined') {\n        var numSymbolsInserted = 0;\n        /* tslint:disable */\n\n        var returnedValue = this.copyToResult(result, lineResult, lines,\n        /*out*/\n        numSymbolsInserted);\n        /* tslint:enable */\n\n        var success = returnedValue.success;\n        numSymbolsInserted = returnedValue.numInserted;\n\n        if (!success) {\n          this.reader.read(numSymbolsInserted);\n          break;\n        }\n      } // if (lineResult.textRemainder != null && lineResult.textRemainder.length > 0 ) {\n      //     break;\n      // }\n\n\n      this.reader.readLine();\n      line = this.reader.peekLine();\n      lineIndent = this.getLineIndent(false);\n    }\n\n    this.finalizeResult(result, lines);\n    return result;\n  };\n  /**\n   * Returns `line indent` for the line.\n   * @private\n   */\n\n\n  PdfStringLayouter.prototype.getLineIndent = function (firstLine) {\n    var lineIndent = 0;\n\n    if (this.format != null) {\n      lineIndent = firstLine ? this.format.firstLineIndent : this.format.paragraphIndent;\n      lineIndent = this.size.width > 0 ? Math.min(this.size.width, lineIndent) : lineIndent;\n    }\n\n    return lineIndent;\n  };\n  /**\n   * Calculates `height` of the line.\n   * @private\n   */\n\n\n  PdfStringLayouter.prototype.getLineHeight = function () {\n    var height = this.font.height;\n\n    if (this.format != null && this.format.lineSpacing !== 0) {\n      height = this.format.lineSpacing + this.font.height;\n    }\n\n    return height;\n  };\n  /**\n   * Calculates `width` of the line.\n   * @private\n   */\n\n\n  PdfStringLayouter.prototype.getLineWidth = function (line) {\n    var width = this.font.getLineWidth(line, this.format);\n    return width;\n  }; // tslint:disable\n\n  /**\n   * `Layouts` line.\n   * @private\n   */\n\n\n  PdfStringLayouter.prototype.layoutLine = function (line, lineIndent) {\n    var lineResult = new PdfStringLayoutResult();\n    lineResult.layoutLineHeight = this.getLineHeight();\n    var lines = [];\n    var maxWidth = this.size.width;\n    var lineWidth = this.getLineWidth(line) + lineIndent;\n    var lineType = LineType.FirstParagraphLine;\n    var readWord = true; // line is in bounds.\n\n    if (maxWidth <= 0 || Math.round(lineWidth) <= Math.round(maxWidth)) {\n      this.addToLineResult(lineResult, lines, line, lineWidth, LineType.NewLineBreak | lineType);\n    } else {\n      var builder = '';\n      var curLine = '';\n      lineWidth = lineIndent;\n      var curIndent = lineIndent;\n      var reader = new StringTokenizer(line);\n      var word = reader.peekWord();\n      var isSingleWord = false;\n\n      if (word.length !== reader.length) {\n        if (word === ' ') {\n          curLine = curLine + word;\n          builder = builder + word;\n          reader.position += 1;\n          word = reader.peekWord();\n        }\n      }\n\n      while (word != null) {\n        curLine = curLine + word;\n        var curLineWidth = this.getLineWidth(curLine.toString()) + curIndent\n        /*)*/\n        ;\n\n        if (curLine.toString() === ' ') {\n          curLine = '';\n          curLineWidth = 0;\n        }\n\n        if (curLineWidth > maxWidth) {\n          if (this.getWrapType() === PdfWordWrapType.None) {\n            break;\n          }\n\n          if (curLine.length === word.length) {\n            //  Character wrap is disabled or one symbol is greater than bounds.\n            if (this.getWrapType() === PdfWordWrapType.WordOnly) {\n              lineResult.textRemainder = line.substring(reader.position);\n              break;\n            } else if (curLine.length === 1) {\n              builder = builder + word;\n              break;\n            } else {\n              readWord = false;\n              curLine = '';\n              word = reader.peek().toString();\n              continue;\n            }\n          } else {\n            if (this.getLineWidth(word.toString()) > maxWidth) {\n              this.format.wordWrap = PdfWordWrapType.Character;\n            } else {\n              if (typeof this.format !== 'undefined' && this.format !== null) {\n                this.format.wordWrap = PdfWordWrapType.Word;\n              }\n            }\n\n            if (this.getWrapType() !== PdfWordWrapType.Character || !readWord) {\n              var ln = builder.toString(); // if (ln.indexOf(' ') === -1) {\n              //     isSingleWord = true;\n              //     this.addToLineResult(lineResult, lines, curLine, lineWidth, LineType.LayoutBreak | lineType);\n              // } else {\n              //     this.addToLineResult(lineResult, lines, ln, lineWidth, LineType.LayoutBreak | lineType);\n              // }                          \n\n              if (ln !== ' ') {\n                this.addToLineResult(lineResult, lines, ln, lineWidth, LineType.LayoutBreak | lineType);\n              }\n\n              if (this.isOverloadWithPosition) {\n                maxWidth = this.clientSize.width;\n              }\n\n              curLine = '';\n              builder = '';\n              lineWidth = 0;\n              curIndent = 0;\n              curLineWidth = 0;\n              lineType = LineType.None; // if (isSingleWord) {\n              //     reader.readWord();\n              //     readWord = false;\n              // }\n\n              word = readWord ? word : reader.peekWord(); //isSingleWord = false;\n\n              readWord = true;\n            } else {\n              readWord = false;\n              curLine = '';\n              curLine = curLine + builder.toString();\n              word = reader.peek().toString();\n            }\n\n            continue;\n          }\n        }\n        /*tslint:disable:max-func-body-length */\n\n\n        builder = builder + word;\n        lineWidth = curLineWidth;\n\n        if (readWord) {\n          reader.readWord();\n          word = reader.peekWord(); //isSingleWord = false;\n        } else {\n          reader.read();\n          word = reader.peek().toString();\n        }\n      }\n\n      if (builder.length > 0) {\n        var ln = builder.toString();\n        this.addToLineResult(lineResult, lines, ln, lineWidth, LineType.NewLineBreak | LineType.LastParagraphLine);\n      }\n\n      reader.close();\n    }\n\n    lineResult.layoutLines = [];\n\n    for (var index = 0; index < lines.length; index++) {\n      lineResult.layoutLines.push(lines[index]);\n    }\n\n    lines = [];\n    return lineResult;\n  };\n  /**\n   * `Adds` line to line result.\n   * @private\n   */\n\n\n  PdfStringLayouter.prototype.addToLineResult = function (lineResult, lines, line, lineWidth, breakType) {\n    var info = new LineInfo();\n    info.text = line;\n    info.width = lineWidth;\n    info.lineType = breakType;\n    lines.push(info);\n    var size = lineResult.actualSize;\n    size.height += this.getLineHeight();\n    size.width = Math.max(size.width, lineWidth);\n    lineResult.size = size;\n  };\n  /**\n   * `Copies` layout result from line result to entire result. Checks whether we can proceed lay outing or not.\n   * @private\n   */\n\n\n  PdfStringLayouter.prototype.copyToResult = function (result, lineResult, lines,\n  /*out*/\n  numInserted) {\n    var success = true;\n    var allowPartialLines = this.format != null && !this.format.lineLimit;\n    var height = result.actualSize.height;\n    var maxHeight = this.size.height;\n\n    if (this.pageHeight > 0 && maxHeight + this.rectangle.y > this.pageHeight) {\n      maxHeight = this.rectangle.y - this.pageHeight;\n      maxHeight = Math.max(maxHeight, -maxHeight);\n    }\n\n    numInserted = 0;\n\n    if (lineResult.lines != null) {\n      for (var i = 0, len = lineResult.lines.length; i < len; i++) {\n        var expHeight = height + lineResult.lineHeight;\n\n        if (expHeight <= maxHeight || maxHeight <= 0 || allowPartialLines) {\n          var info = lineResult.lines[i];\n          numInserted += info.text.length;\n          info = this.trimLine(info, lines.length === 0);\n          lines.push(info); // Update width.\n\n          var size = result.actualSize;\n          size.width = Math.max(size.width, info.width);\n          result.size = size; // The part of the line fits only and it's allowed to use partial lines.\n          // if (expHeight >= maxHeight && maxHeight > 0 && allowPartialLines)\n          // {\n          //     let shouldClip : boolean = (this.format == null || !this.format.noClip);\n          //     if (shouldClip)\n          //     {\n          //         let exceededHeight : number = expHeight - maxHeight;\n          //         let fitHeight : number  = /*Utils.Round(*/ lineResult.lineHeight - exceededHeight /*)*/;\n          //         height = /*Utils.Round(*/ height + fitHeight /*)*/;\n          //     }\n          //     else\n          //     {\n          //         height = expHeight;\n          //     }\n          //     success = false;\n          //     break;\n          // } else {\n\n          height = expHeight; // }\n        } else {\n          success = false;\n          break;\n        }\n      }\n    }\n\n    if (height != result.size.height) {\n      var size1 = result.actualSize;\n      size1.height = height;\n      result.size = size1;\n    }\n\n    return {\n      success: success,\n      numInserted: numInserted\n    };\n  };\n  /**\n   * `Finalizes` final result.\n   * @private\n   */\n\n\n  PdfStringLayouter.prototype.finalizeResult = function (result, lines) {\n    result.layoutLines = [];\n\n    for (var index = 0; index < lines.length; index++) {\n      result.layoutLines.push(lines[index]);\n    }\n\n    result.layoutLineHeight = this.getLineHeight();\n\n    if (!this.reader.end) {\n      result.textRemainder = this.reader.readToEnd();\n    }\n\n    lines = [];\n  };\n  /**\n   * `Trims` whitespaces at the line.\n   * @private\n   */\n\n\n  PdfStringLayouter.prototype.trimLine = function (info, firstLine) {\n    var line = info.text;\n    var lineWidth = info.width; // Trim start whitespaces if the line is not a start of the paragraph only.\n\n    var trimStartSpaces = (info.lineType & LineType.FirstParagraphLine) === 0;\n    var start = this.format == null || !this.format.rightToLeft;\n    var spaces = StringTokenizer.spaces;\n    line = start ? line.trim() : line.trim(); // Recalculate line width.\n\n    if (line.length !== info.text.length) {\n      lineWidth = this.getLineWidth(line);\n\n      if ((info.lineType & LineType.FirstParagraphLine) > 0) {\n        lineWidth += this.getLineIndent(firstLine);\n      }\n    }\n\n    info.text = line;\n    info.width = lineWidth;\n    return info;\n  };\n  /**\n   * Returns `wrap` type.\n   * @private\n   */\n\n\n  PdfStringLayouter.prototype.getWrapType = function () {\n    var wrapType = this.format != null ? this.format.wordWrap : PdfWordWrapType.Word;\n    return wrapType;\n  };\n\n  return PdfStringLayouter;\n}();\n\nexport { PdfStringLayouter }; //Internal declaration\n\nvar PdfStringLayoutResult =\n/** @class */\nfunction () {\n  function PdfStringLayoutResult() {}\n\n  Object.defineProperty(PdfStringLayoutResult.prototype, \"remainder\", {\n    // Properties\n\n    /**\n     * Gets the `text` which is not lay outed.\n     * @private\n     */\n    get: function () {\n      return this.textRemainder;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PdfStringLayoutResult.prototype, \"actualSize\", {\n    /**\n     * Gets the actual layout text `bounds`.\n     * @private\n     */\n    get: function () {\n      if (typeof this.size === 'undefined') {\n        this.size = new SizeF(0, 0);\n      }\n\n      return this.size;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PdfStringLayoutResult.prototype, \"lines\", {\n    /**\n     * Gets layout `lines` information.\n     * @private\n     */\n    get: function () {\n      return this.layoutLines;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PdfStringLayoutResult.prototype, \"lineHeight\", {\n    /**\n     * Gets the `height` of the line.\n     * @private\n     */\n    get: function () {\n      return this.layoutLineHeight;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PdfStringLayoutResult.prototype, \"empty\", {\n    /**\n     * Gets value that indicates whether any layout text [`empty`].\n     * @private\n     */\n    get: function () {\n      return this.layoutLines == null || this.layoutLines.length === 0;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PdfStringLayoutResult.prototype, \"lineCount\", {\n    /**\n     * Gets `number of` the layout lines.\n     * @private\n     */\n    get: function () {\n      var count = !this.empty ? this.layoutLines.length : 0;\n      return count;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return PdfStringLayoutResult;\n}();\n\nexport { PdfStringLayoutResult };\n\nvar LineInfo =\n/** @class */\nfunction () {\n  function LineInfo() {}\n\n  Object.defineProperty(LineInfo.prototype, \"lineType\", {\n    //Properties\n\n    /**\n     * Gets the `type` of the line text.\n     * @private\n     */\n    get: function () {\n      return this.type;\n    },\n    set: function (value) {\n      this.type = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(LineInfo.prototype, \"text\", {\n    /**\n     * Gets the line `text`.\n     * @private\n     */\n    get: function () {\n      return this.content;\n    },\n    set: function (value) {\n      this.content = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(LineInfo.prototype, \"width\", {\n    /**\n     * Gets `width` of the line text.\n     * @private\n     */\n    get: function () {\n      return this.lineWidth;\n    },\n    set: function (value) {\n      this.lineWidth = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return LineInfo;\n}();\n\nexport { LineInfo };\n/**\n* Break type of the `line`.\n* @private\n*/\n\nexport var LineType;\n\n(function (LineType) {\n  /**\n   * Specifies the type of `None`.\n   * @private\n   */\n  LineType[LineType[\"None\"] = 0] = \"None\";\n  /**\n   * Specifies the type of `NewLineBreak`.\n   * @private\n   */\n\n  LineType[LineType[\"NewLineBreak\"] = 1] = \"NewLineBreak\";\n  /**\n   * Specifies the type of `LayoutBreak`.\n   * @private\n   */\n\n  LineType[LineType[\"LayoutBreak\"] = 2] = \"LayoutBreak\";\n  /**\n   * Specifies the type of `FirstParagraphLine`.\n   * @private\n   */\n\n  LineType[LineType[\"FirstParagraphLine\"] = 4] = \"FirstParagraphLine\";\n  /**\n   * Specifies the type of `LastParagraphLine`.\n   * @private\n   */\n\n  LineType[LineType[\"LastParagraphLine\"] = 8] = \"LastParagraphLine\";\n})(LineType || (LineType = {}));","map":{"version":3,"sources":["C:/Users/khang/OneDrive/Tài liệu/JS/PersonalDashdoard/dashboard/node_modules/@syncfusion/ej2-react-charts/node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/string-layouter.js"],"names":["SizeF","RectangleF","PointF","PdfWordWrapType","StringTokenizer","PdfStringLayouter","isOverloadWithPosition","prototype","layout","arg1","arg2","arg3","arg4","arg5","arg6","arg7","initialize","clientSize","result","doLayout","clear","text","font","format","rectSize","pageHeight","Error","size","width","height","rectangle","reader","close","PdfStringLayoutResult","lineResult","lines","line","peekLine","lineIndent","getLineIndent","layoutLine","numSymbolsInserted","returnedValue","copyToResult","success","numInserted","read","readLine","finalizeResult","firstLine","firstLineIndent","paragraphIndent","Math","min","getLineHeight","lineSpacing","getLineWidth","layoutLineHeight","maxWidth","lineWidth","lineType","LineType","FirstParagraphLine","readWord","round","addToLineResult","NewLineBreak","builder","curLine","curIndent","word","peekWord","isSingleWord","length","position","curLineWidth","toString","getWrapType","None","WordOnly","textRemainder","substring","peek","wordWrap","Character","Word","ln","LayoutBreak","LastParagraphLine","layoutLines","index","push","breakType","info","LineInfo","actualSize","max","allowPartialLines","lineLimit","maxHeight","y","i","len","expHeight","lineHeight","trimLine","size1","end","readToEnd","trimStartSpaces","start","rightToLeft","spaces","trim","wrapType","Object","defineProperty","get","enumerable","configurable","count","empty","type","set","value","content"],"mappings":"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","sourcesContent":["import { SizeF, RectangleF, PointF } from './../../drawing/pdf-drawing';\nimport { PdfWordWrapType } from './enum';\nimport { StringTokenizer } from './string-tokenizer';\n/**\n * Class `lay outing the text`.\n */\nvar PdfStringLayouter = /** @class */ (function () {\n    // Constructors\n    /**\n     * Initializes a new instance of the `StringLayouter` class.\n     * @private\n     */\n    function PdfStringLayouter() {\n        /**\n         * Checks whether the x co-ordinate is need to set as client size or not.\n         * @hidden\n         * @private\n         */\n        this.isOverloadWithPosition = false;\n        //\n    }\n    PdfStringLayouter.prototype.layout = function (arg1, arg2, arg3, arg4, arg5, arg6, arg7) {\n        if (arg4 instanceof RectangleF) {\n            this.initialize(arg1, arg2, arg3, arg4, arg5);\n            this.isOverloadWithPosition = arg6;\n            this.clientSize = arg7;\n            var result = this.doLayout();\n            this.clear();\n            return result;\n        }\n        else {\n            this.initialize(arg1, arg2, arg3, arg4);\n            this.isOverloadWithPosition = arg5;\n            this.clientSize = arg6;\n            var result = this.doLayout();\n            this.clear();\n            return result;\n        }\n    };\n    PdfStringLayouter.prototype.initialize = function (text, font, format, rectSize, pageHeight) {\n        if (typeof pageHeight === 'number') {\n            if (text == null) {\n                throw new Error('ArgumentNullException:text');\n            }\n            if (font == null) {\n                throw new Error('ArgumentNullException:font');\n            }\n            this.text = text;\n            this.font = font;\n            this.format = format;\n            this.size = new SizeF(rectSize.width, rectSize.height);\n            this.rectangle = rectSize;\n            this.pageHeight = pageHeight;\n            this.reader = new StringTokenizer(text);\n        }\n        else {\n            this.initialize(text, font, format, new RectangleF(new PointF(0, 0), rectSize), 0);\n        }\n    };\n    /**\n     * `Clear` all resources.\n     * @private\n     */\n    PdfStringLayouter.prototype.clear = function () {\n        this.font = null;\n        this.format = null;\n        this.reader.close();\n        this.reader = null;\n        this.text = null;\n    };\n    /**\n     * `Layouts` the text.\n     * @private\n     */\n    PdfStringLayouter.prototype.doLayout = function () {\n        var result = new PdfStringLayoutResult();\n        var lineResult = new PdfStringLayoutResult();\n        var lines = [];\n        var line = this.reader.peekLine();\n        var lineIndent = this.getLineIndent(true);\n        while (line != null) {\n            lineResult = this.layoutLine(line, lineIndent);\n            if (lineResult !== null || typeof lineResult !== 'undefined') {\n                var numSymbolsInserted = 0;\n                /* tslint:disable */\n                var returnedValue = this.copyToResult(result, lineResult, lines, /*out*/ numSymbolsInserted);\n                /* tslint:enable */\n                var success = returnedValue.success;\n                numSymbolsInserted = returnedValue.numInserted;\n                if (!success) {\n                    this.reader.read(numSymbolsInserted);\n                    break;\n                }\n            }\n            // if (lineResult.textRemainder != null && lineResult.textRemainder.length > 0 ) {\n            //     break;\n            // }\n            this.reader.readLine();\n            line = this.reader.peekLine();\n            lineIndent = this.getLineIndent(false);\n        }\n        this.finalizeResult(result, lines);\n        return result;\n    };\n    /**\n     * Returns `line indent` for the line.\n     * @private\n     */\n    PdfStringLayouter.prototype.getLineIndent = function (firstLine) {\n        var lineIndent = 0;\n        if (this.format != null) {\n            lineIndent = (firstLine) ? this.format.firstLineIndent : this.format.paragraphIndent;\n            lineIndent = (this.size.width > 0) ? Math.min(this.size.width, lineIndent) : lineIndent;\n        }\n        return lineIndent;\n    };\n    /**\n     * Calculates `height` of the line.\n     * @private\n     */\n    PdfStringLayouter.prototype.getLineHeight = function () {\n        var height = this.font.height;\n        if (this.format != null && this.format.lineSpacing !== 0) {\n            height = this.format.lineSpacing + this.font.height;\n        }\n        return height;\n    };\n    /**\n     * Calculates `width` of the line.\n     * @private\n     */\n    PdfStringLayouter.prototype.getLineWidth = function (line) {\n        var width = this.font.getLineWidth(line, this.format);\n        return width;\n    };\n    // tslint:disable\n    /**\n     * `Layouts` line.\n     * @private\n     */\n    PdfStringLayouter.prototype.layoutLine = function (line, lineIndent) {\n        var lineResult = new PdfStringLayoutResult();\n        lineResult.layoutLineHeight = this.getLineHeight();\n        var lines = [];\n        var maxWidth = this.size.width;\n        var lineWidth = this.getLineWidth(line) + lineIndent;\n        var lineType = LineType.FirstParagraphLine;\n        var readWord = true;\n        // line is in bounds.\n        if (maxWidth <= 0 || Math.round(lineWidth) <= Math.round(maxWidth)) {\n            this.addToLineResult(lineResult, lines, line, lineWidth, LineType.NewLineBreak | lineType);\n        }\n        else {\n            var builder = '';\n            var curLine = '';\n            lineWidth = lineIndent;\n            var curIndent = lineIndent;\n            var reader = new StringTokenizer(line);\n            var word = reader.peekWord();\n            var isSingleWord = false;\n            if (word.length !== reader.length) {\n                if (word === ' ') {\n                    curLine = curLine + word;\n                    builder = builder + word;\n                    reader.position += 1;\n                    word = reader.peekWord();\n                }\n            }\n            while (word != null) {\n                curLine = curLine + word;\n                var curLineWidth = this.getLineWidth(curLine.toString()) + curIndent /*)*/;\n                if (curLine.toString() === ' ') {\n                    curLine = '';\n                    curLineWidth = 0;\n                }\n                if (curLineWidth > maxWidth) {\n                    if (this.getWrapType() === PdfWordWrapType.None) {\n                        break;\n                    }\n                    if (curLine.length === word.length) {\n                        //  Character wrap is disabled or one symbol is greater than bounds.\n                        if (this.getWrapType() === PdfWordWrapType.WordOnly) {\n                            lineResult.textRemainder = line.substring(reader.position);\n                            break;\n                        }\n                        else if (curLine.length === 1) {\n                            builder = builder + word;\n                            break;\n                        }\n                        else {\n                            readWord = false;\n                            curLine = '';\n                            word = reader.peek().toString();\n                            continue;\n                        }\n                    }\n                    else {\n                        if (this.getLineWidth(word.toString()) > maxWidth) {\n                            this.format.wordWrap = PdfWordWrapType.Character;\n                        }\n                        else {\n                            if (typeof this.format !== 'undefined' && this.format !== null) {\n                                this.format.wordWrap = PdfWordWrapType.Word;\n                            }\n                        }\n                        if (this.getWrapType() !== PdfWordWrapType.Character || !readWord) {\n                            var ln = builder.toString();\n                            // if (ln.indexOf(' ') === -1) {\n                            //     isSingleWord = true;\n                            //     this.addToLineResult(lineResult, lines, curLine, lineWidth, LineType.LayoutBreak | lineType);\n                            // } else {\n                            //     this.addToLineResult(lineResult, lines, ln, lineWidth, LineType.LayoutBreak | lineType);\n                            // }                          \n                            if (ln !== ' ') {\n                                this.addToLineResult(lineResult, lines, ln, lineWidth, LineType.LayoutBreak | lineType);\n                            }\n                            if (this.isOverloadWithPosition) {\n                                maxWidth = this.clientSize.width;\n                            }\n                            curLine = '';\n                            builder = '';\n                            lineWidth = 0;\n                            curIndent = 0;\n                            curLineWidth = 0;\n                            lineType = LineType.None;\n                            // if (isSingleWord) {\n                            //     reader.readWord();\n                            //     readWord = false;\n                            // }\n                            word = (readWord) ? word : reader.peekWord();\n                            //isSingleWord = false;\n                            readWord = true;\n                        }\n                        else {\n                            readWord = false;\n                            curLine = '';\n                            curLine = curLine + builder.toString();\n                            word = reader.peek().toString();\n                        }\n                        continue;\n                    }\n                }\n                /*tslint:disable:max-func-body-length */\n                builder = builder + word;\n                lineWidth = curLineWidth;\n                if (readWord) {\n                    reader.readWord();\n                    word = reader.peekWord();\n                    //isSingleWord = false;\n                }\n                else {\n                    reader.read();\n                    word = reader.peek().toString();\n                }\n            }\n            if (builder.length > 0) {\n                var ln = builder.toString();\n                this.addToLineResult(lineResult, lines, ln, lineWidth, LineType.NewLineBreak | LineType.LastParagraphLine);\n            }\n            reader.close();\n        }\n        lineResult.layoutLines = [];\n        for (var index = 0; index < lines.length; index++) {\n            lineResult.layoutLines.push(lines[index]);\n        }\n        lines = [];\n        return lineResult;\n    };\n    /**\n     * `Adds` line to line result.\n     * @private\n     */\n    PdfStringLayouter.prototype.addToLineResult = function (lineResult, lines, line, lineWidth, breakType) {\n        var info = new LineInfo();\n        info.text = line;\n        info.width = lineWidth;\n        info.lineType = breakType;\n        lines.push(info);\n        var size = lineResult.actualSize;\n        size.height += this.getLineHeight();\n        size.width = Math.max(size.width, lineWidth);\n        lineResult.size = size;\n    };\n    /**\n     * `Copies` layout result from line result to entire result. Checks whether we can proceed lay outing or not.\n     * @private\n     */\n    PdfStringLayouter.prototype.copyToResult = function (result, lineResult, lines, \n    /*out*/ numInserted) {\n        var success = true;\n        var allowPartialLines = (this.format != null && !this.format.lineLimit);\n        var height = result.actualSize.height;\n        var maxHeight = this.size.height;\n        if ((this.pageHeight > 0) && (maxHeight + this.rectangle.y > this.pageHeight)) {\n            maxHeight = this.rectangle.y - this.pageHeight;\n            maxHeight = Math.max(maxHeight, -maxHeight);\n        }\n        numInserted = 0;\n        if (lineResult.lines != null) {\n            for (var i = 0, len = lineResult.lines.length; i < len; i++) {\n                var expHeight = height + lineResult.lineHeight;\n                if (expHeight <= maxHeight || maxHeight <= 0 || allowPartialLines) {\n                    var info = lineResult.lines[i];\n                    numInserted += info.text.length;\n                    info = this.trimLine(info, (lines.length === 0));\n                    lines.push(info);\n                    // Update width.\n                    var size = result.actualSize;\n                    size.width = Math.max(size.width, info.width);\n                    result.size = size;\n                    // The part of the line fits only and it's allowed to use partial lines.\n                    // if (expHeight >= maxHeight && maxHeight > 0 && allowPartialLines)\n                    // {\n                    //     let shouldClip : boolean = (this.format == null || !this.format.noClip);\n                    //     if (shouldClip)\n                    //     {\n                    //         let exceededHeight : number = expHeight - maxHeight;\n                    //         let fitHeight : number  = /*Utils.Round(*/ lineResult.lineHeight - exceededHeight /*)*/;\n                    //         height = /*Utils.Round(*/ height + fitHeight /*)*/;\n                    //     }\n                    //     else\n                    //     {\n                    //         height = expHeight;\n                    //     }\n                    //     success = false;\n                    //     break;\n                    // } else {\n                    height = expHeight;\n                    // }\n                }\n                else {\n                    success = false;\n                    break;\n                }\n            }\n        }\n        if (height != result.size.height) {\n            var size1 = result.actualSize;\n            size1.height = height;\n            result.size = size1;\n        }\n        return { success: success, numInserted: numInserted };\n    };\n    /**\n     * `Finalizes` final result.\n     * @private\n     */\n    PdfStringLayouter.prototype.finalizeResult = function (result, lines) {\n        result.layoutLines = [];\n        for (var index = 0; index < lines.length; index++) {\n            result.layoutLines.push(lines[index]);\n        }\n        result.layoutLineHeight = this.getLineHeight();\n        if (!this.reader.end) {\n            result.textRemainder = this.reader.readToEnd();\n        }\n        lines = [];\n    };\n    /**\n     * `Trims` whitespaces at the line.\n     * @private\n     */\n    PdfStringLayouter.prototype.trimLine = function (info, firstLine) {\n        var line = info.text;\n        var lineWidth = info.width;\n        // Trim start whitespaces if the line is not a start of the paragraph only.\n        var trimStartSpaces = ((info.lineType & LineType.FirstParagraphLine) === 0);\n        var start = (this.format == null || !this.format.rightToLeft);\n        var spaces = StringTokenizer.spaces;\n        line = (start) ? line.trim() : line.trim();\n        // Recalculate line width.\n        if (line.length !== info.text.length) {\n            lineWidth = this.getLineWidth(line);\n            if ((info.lineType & LineType.FirstParagraphLine) > 0) {\n                lineWidth += this.getLineIndent(firstLine);\n            }\n        }\n        info.text = line;\n        info.width = lineWidth;\n        return info;\n    };\n    /**\n     * Returns `wrap` type.\n     * @private\n     */\n    PdfStringLayouter.prototype.getWrapType = function () {\n        var wrapType = (this.format != null) ? this.format.wordWrap : PdfWordWrapType.Word;\n        return wrapType;\n    };\n    return PdfStringLayouter;\n}());\nexport { PdfStringLayouter };\n//Internal declaration\nvar PdfStringLayoutResult = /** @class */ (function () {\n    function PdfStringLayoutResult() {\n    }\n    Object.defineProperty(PdfStringLayoutResult.prototype, \"remainder\", {\n        // Properties\n        /**\n         * Gets the `text` which is not lay outed.\n         * @private\n         */\n        get: function () {\n            return this.textRemainder;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfStringLayoutResult.prototype, \"actualSize\", {\n        /**\n         * Gets the actual layout text `bounds`.\n         * @private\n         */\n        get: function () {\n            if (typeof this.size === 'undefined') {\n                this.size = new SizeF(0, 0);\n            }\n            return this.size;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfStringLayoutResult.prototype, \"lines\", {\n        /**\n         * Gets layout `lines` information.\n         * @private\n         */\n        get: function () {\n            return this.layoutLines;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfStringLayoutResult.prototype, \"lineHeight\", {\n        /**\n         * Gets the `height` of the line.\n         * @private\n         */\n        get: function () {\n            return this.layoutLineHeight;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfStringLayoutResult.prototype, \"empty\", {\n        /**\n         * Gets value that indicates whether any layout text [`empty`].\n         * @private\n         */\n        get: function () {\n            return (this.layoutLines == null || this.layoutLines.length === 0);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfStringLayoutResult.prototype, \"lineCount\", {\n        /**\n         * Gets `number of` the layout lines.\n         * @private\n         */\n        get: function () {\n            var count = (!this.empty) ? this.layoutLines.length : 0;\n            return count;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return PdfStringLayoutResult;\n}());\nexport { PdfStringLayoutResult };\nvar LineInfo = /** @class */ (function () {\n    function LineInfo() {\n    }\n    Object.defineProperty(LineInfo.prototype, \"lineType\", {\n        //Properties\n        /**\n         * Gets the `type` of the line text.\n         * @private\n         */\n        get: function () {\n            return this.type;\n        },\n        set: function (value) {\n            this.type = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LineInfo.prototype, \"text\", {\n        /**\n         * Gets the line `text`.\n         * @private\n         */\n        get: function () {\n            return this.content;\n        },\n        set: function (value) {\n            this.content = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LineInfo.prototype, \"width\", {\n        /**\n         * Gets `width` of the line text.\n         * @private\n         */\n        get: function () {\n            return this.lineWidth;\n        },\n        set: function (value) {\n            this.lineWidth = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return LineInfo;\n}());\nexport { LineInfo };\n/**\n* Break type of the `line`.\n* @private\n*/\nexport var LineType;\n(function (LineType) {\n    /**\n     * Specifies the type of `None`.\n     * @private\n     */\n    LineType[LineType[\"None\"] = 0] = \"None\";\n    /**\n     * Specifies the type of `NewLineBreak`.\n     * @private\n     */\n    LineType[LineType[\"NewLineBreak\"] = 1] = \"NewLineBreak\";\n    /**\n     * Specifies the type of `LayoutBreak`.\n     * @private\n     */\n    LineType[LineType[\"LayoutBreak\"] = 2] = \"LayoutBreak\";\n    /**\n     * Specifies the type of `FirstParagraphLine`.\n     * @private\n     */\n    LineType[LineType[\"FirstParagraphLine\"] = 4] = \"FirstParagraphLine\";\n    /**\n     * Specifies the type of `LastParagraphLine`.\n     * @private\n     */\n    LineType[LineType[\"LastParagraphLine\"] = 8] = \"LastParagraphLine\";\n})(LineType || (LineType = {}));\n"]},"metadata":{},"sourceType":"module"}